/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { XYChart } from "./XYChart";
import { typeCast, runOn, delegateCombine, enumGetBox, markType, TypeRegistrar, getInstanceType } from "igniteui-react-core";
import { CategoryChartType_$type } from "./CategoryChartType";
import { CategorySeriesMarkerCollisionAvoidance_$type } from "./CategorySeriesMarkerCollisionAvoidance";
import { CategoryTransitionInMode_$type } from "./CategoryTransitionInMode";
import { TransitionInSpeedType_$type } from "./TransitionInSpeedType";
import { CategoryXAxis } from "./CategoryXAxis";
import { List$1 } from "igniteui-react-core";
import { DataSeriesType_$type } from "igniteui-react-core";
import { NumericYAxis } from "./NumericYAxis";
import { IDataSeriesAdapterRule_$type } from "igniteui-react-core";
import { SimpleCategorySeriesRule } from "igniteui-react-core";
import { SubCollectionsRule } from "igniteui-react-core";
import { Series } from "./Series";
import { HorizontalAnchoredCategorySeries } from "./HorizontalAnchoredCategorySeries";
import { ArrayExtension } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { AxisLabelSettings } from "./AxisLabelSettings";
import { stringIsNullOrEmpty } from "igniteui-react-core";
/**
 * @hidden
 */
export let CategoryChart = /*@__PURE__*/ (() => {
    class CategoryChart extends XYChart {
        constructor() {
            super();
            this.qj = 1000;
            this.pj = null;
            this.o3 = 9;
            this.o5 = 1;
            this.pn = false;
            this.o7 = 0;
            this.ph = 0;
            this.pw = 0;
            this.px = 0;
            this.pv = 0;
            this.py = 0;
            this.pz = NaN;
            this.pp = false;
            this.qk = 10;
            this.p1 = NaN;
            this.p0 = NaN;
            this.p2 = 0;
            this.oz = null;
            this.o0 = null;
            this.po = true;
            this.pl = false;
            this.pm = false;
            this.f6();
        }
        gj() {
            super.gj();
            if (this.dataChart == null) {
                return;
            }
            let a = this.dataChart.bn.i.e();
            this.o1 = a.d;
            this.o2 = a.e;
            if (this.ob == null) {
                this.ob = a.k;
            }
            if (this.oi == null) {
                this.oi = a.k;
            }
        }
        gl(a, b) {
            super.gl(a, b);
            a.fj = this.ql;
            a.bv = this.pk;
        }
        g4(a, b, c) {
            super.g4(a, b, c);
            switch (a) {
                case "TransitionInDuration":
                    this.ra((d) => d.fj = this.ql);
                    break;
                case "TransitionInEasingFunction":
                    this.ra((d) => d.bv = this.pk);
                    break;
            }
        }
        get ql() {
            return this.qj;
        }
        set ql(a) {
            let b = this.ql;
            if (a != b) {
                this.qj = a;
                this.g3("TransitionInDuration", b, this.ql);
            }
        }
        get pk() {
            return this.pj;
        }
        set pk(a) {
            let b = this.pk;
            if (a != b) {
                this.pj = a;
                this.g3("TransitionInEasingFunction", b, this.pk);
            }
        }
        qo() {
            let cvd_ = this.dj();
            cvd_.scaleByViewport();
            return (cvd_.serialize());
        }
        ge(a) {
            super.ge(a);
            a.cd = this.bg;
        }
        gk(a, b) {
            super.gk(a, b);
            let c = typeCast(HorizontalAnchoredCategorySeries.$, a);
            if (c == null) {
                return;
            }
            c.o4 = this.o6;
            c.n2 = this.ps;
            c.nl = this.o8;
            c.bp = this.pi;
            c.trendLineBrush = ArrayExtension.getModulus$1(Brush.$, this.o, b);
            c.trendLineType = this.av;
            c.trendLineThickness = this.c6;
            c.l2 = this.ai(a, b);
            if (a.cz) {
                a.jj(ArrayExtension.getModulus$1(Brush.$, this.o1, b), ArrayExtension.getModulus$1(Brush.$, this.o2, b));
            }
        }
        o9() {
            return new CategoryXAxis();
        }
        pd() {
            return new NumericYAxis();
        }
        f3() {
            this.xAxis = this.o9();
            this.xAxis.name = "xAxis";
            let a = this.xAxis;
            a.propertyChanged = delegateCombine(a.propertyChanged, runOn(this, this.rc));
            this.yAxis = this.pd();
            this.yAxis.name = "yAxis";
            let b = this.yAxis;
            b.propertyChanged = delegateCombine(b.propertyChanged, runOn(this, this.rd));
            if (this.xAxis.ax == null) {
                this.xAxis.ax = new AxisLabelSettings();
            }
            if (this.yAxis.ax == null) {
                this.yAxis.ax = new AxisLabelSettings();
            }
        }
        nh(a) {
            super.nh(a);
            a.jv = this.pt;
        }
        get o4() {
            return this.o3;
        }
        set o4(a) {
            if (a != this.o3) {
                let b = this.o4;
                this.o3 = a;
                this.g3("ChartType", enumGetBox(CategoryChartType_$type, b), enumGetBox(CategoryChartType_$type, this.o4));
            }
        }
        get o6() {
            return this.o5;
        }
        set o6(a) {
            let b = this.o6;
            if (a != b) {
                this.o5 = a;
                this.g3("MarkerCollisionAvoidance", enumGetBox(CategorySeriesMarkerCollisionAvoidance_$type, b), enumGetBox(CategorySeriesMarkerCollisionAvoidance_$type, this.o6));
            }
        }
        get ps() {
            return this.pn;
        }
        set ps(a) {
            let b = this.ps;
            if (a != b) {
                this.pn = a;
                this.g3("IsTransitionInEnabled", b, this.ps);
            }
        }
        get o8() {
            return this.o7;
        }
        set o8(a) {
            let b = this.o8;
            if (a != b) {
                this.o7 = a;
                this.g3("TransitionInMode", enumGetBox(CategoryTransitionInMode_$type, b), enumGetBox(CategoryTransitionInMode_$type, this.o8));
            }
        }
        get pi() {
            return this.ph;
        }
        set pi(a) {
            let b = this.pi;
            if (a != b) {
                this.ph = a;
                this.g3("TransitionInSpeedType", enumGetBox(TransitionInSpeedType_$type, b), enumGetBox(TransitionInSpeedType_$type, this.pi));
            }
        }
        get qa() {
            return this.pw;
        }
        set qa(a) {
            let b = this.qa;
            if (a != b) {
                this.pw = a;
                this.g3("XAxisInterval", b, this.qa);
            }
        }
        get qb() {
            return this.px;
        }
        set qb(a) {
            let b = this.qb;
            if (a != b) {
                this.px = a;
                this.g3("XAxisMinorInterval", b, this.qb);
            }
        }
        get p9() {
            return this.pv;
        }
        set p9(a) {
            let b = this.p9;
            if (a != b) {
                this.pv = a;
                this.g3("XAxisGap", b, this.p9);
            }
        }
        get qc() {
            return this.py;
        }
        set qc(a) {
            let b = this.qc;
            if (a != b) {
                this.py = a;
                this.g3("XAxisOverlap", b, this.qc);
            }
        }
        get qf() {
            return this.pz;
        }
        set qf(a) {
            let b = this.qf;
            if (a != b) {
                this.pz = a;
                this.g3("YAxisInterval", b, this.qf);
            }
        }
        get pu() {
            return this.pp;
        }
        set pu(a) {
            let b = this.pu;
            if (a != b) {
                this.pp = a;
                this.g3("YAxisIsLogarithmic", b, this.pu);
            }
        }
        get qm() {
            return this.qk;
        }
        set qm(a) {
            let b = this.qm;
            if (a != b) {
                this.qk = a;
                this.g3("YAxisLogarithmBase", b, this.qm);
            }
        }
        get qh() {
            return this.p1;
        }
        set qh(a) {
            let b = this.qh;
            if (a != b) {
                this.p1 = a;
                this.g3("YAxisMinimumValue", b, this.qh);
            }
        }
        get qg() {
            return this.p0;
        }
        set qg(a) {
            let b = this.qg;
            if (a != b) {
                this.p0 = a;
                this.g3("YAxisMaximumValue", b, this.qg);
            }
        }
        get qi() {
            return this.p2;
        }
        set qi(a) {
            let b = this.qi;
            if (a != b) {
                this.p2 = a;
                this.g3("YAxisMinorInterval", b, this.qi);
            }
        }
        get p8() {
            return this.xAxis.li;
        }
        get p7() {
            return this.xAxis.lh;
        }
        p4() {
            return this.p8;
        }
        p6() {
            return this.qe;
        }
        p3() {
            return this.p7;
        }
        p5() {
            return this.qd;
        }
        get qe() {
            return this.yAxis.kb;
        }
        get qd() {
            return this.yAxis.ka;
        }
        get o1() {
            return this.oz;
        }
        set o1(a) {
            let b = this.o1;
            if (a != b) {
                this.oz = a;
                this.g3("NegativeBrushes", b, this.o1);
            }
        }
        get o2() {
            return this.o0;
        }
        set o2(a) {
            let b = this.o2;
            if (a != b) {
                this.o0 = a;
                this.g3("NegativeOutlines", b, this.o2);
            }
        }
        get pt() {
            return this.po;
        }
        set pt(a) {
            let b = this.pt;
            if (a != b) {
                this.po = a;
                this.g3("YAxisAbbreviateLargeNumbers", b, this.pt);
            }
        }
        get pq() {
            return this.pl;
        }
        set pq(a) {
            let b = this.pq;
            if (a != b) {
                this.pl = a;
                this.g3("IsCategoryHighlightingEnabled", b, this.pq);
            }
        }
        get pr() {
            return this.pm;
        }
        set pr(a) {
            let b = this.pr;
            if (a != b) {
                this.pm = a;
                this.g3("IsItemHighlightingEnabled", b, this.pr);
            }
        }
        get_b5() {
            let a = new List$1(DataSeriesType_$type, 0);
            if (TypeRegistrar.isRegistered("AreaSeries")) {
                a.add(2);
            }
            if (TypeRegistrar.isRegistered("ColumnSeries")) {
                a.add(1);
            }
            if (TypeRegistrar.isRegistered("LineSeries")) {
                a.add(0);
            }
            if (TypeRegistrar.isRegistered("PointSeries")) {
                a.add(10);
            }
            if (TypeRegistrar.isRegistered("SplineSeries")) {
                a.add(6);
            }
            if (TypeRegistrar.isRegistered("SplineAreaSeries")) {
                a.add(7);
            }
            if (TypeRegistrar.isRegistered("StepAreaSeries")) {
                a.add(5);
            }
            if (TypeRegistrar.isRegistered("StepLineSeries")) {
                a.add(4);
            }
            if (TypeRegistrar.isRegistered("WaterfallSeries")) {
                a.add(8);
            }
            return a;
        }
        get b5() {
            return this.get_b5();
        }
        rc(a, b) {
            switch (b.propertyName) {
                case "ActualMinimum":
                    this.ha("XAxisActualMinimum");
                    break;
                case "ActualMaximum":
                    this.ha("XAxisActualMaximum");
                    break;
            }
        }
        rd(a, b) {
            switch (b.propertyName) {
                case "ActualMinimumValue":
                    this.ha("YAxisActualMinimum");
                    break;
                case "ActualMaximumValue":
                    this.ha("YAxisActualMaximum");
                    break;
            }
        }
        hl() {
            super.hl();
            this.xAxis.e9 = this.kt == null ? XYChart.k3(this.xAxis, this.v.dataSeries) : this.kt;
            this.xAxis.itemsSource = this.dataChart != null && this.dataChart.series.count > 0 ? this.dataChart.series._inner[0].itemsSource : null;
        }
        get xAxis() {
            return this._xAxis;
        }
        set xAxis(a) {
            this._xAxis = a;
        }
        get yAxis() {
            return this._yAxis;
        }
        set yAxis(a) {
            this._yAxis = a;
        }
        pc(a, b) {
            switch (a) {
                case 2: return this.ar(1);
                case 3: return this.ar(10);
                case 0: return this.ar(0);
                case 1: return this.ar(2);
                case 6: return this.ar(6);
                case 7: return this.ar(7);
                case 4: return this.ar(4);
                case 5: return this.ar(5);
                case 8: return this.ar(8);
                case 9: return this.pb(b);
                default: return this.ar(1);
            }
        }
        pb(a) {
            return this.ar(a);
        }
        u(a) {
            switch (this.o4) {
                case 1: return 2;
                case 0: return 0;
                case 3: return 10;
                case 6: return 6;
                case 7: return 7;
                case 5: return 5;
                case 4: return 4;
                case 8: return 8;
                case 9: return a.suggestedSeries;
                default:
                case 2: return 1;
            }
        }
        aq(a, b) {
            let c = this.pc(this.o4, a.suggestedSeries);
            c.ph = a.findMatchingHint(0).path;
            c.xAxis = this.xAxis;
            c.yAxis = this.yAxis;
            return c;
        }
        hj(a) {
            if (a.suggestedSecondaryAxis == 2) {
                this.yAxis.j0 = true;
                this.yAxis.kn = 10;
            }
        }
        hm() {
            this.yAxis.j0 = this.pu;
            this.yAxis.kn = this.qm;
        }
        get_b4() {
            return ((() => {
                let $ret = new List$1(IDataSeriesAdapterRule_$type, 0);
                $ret.add(new SimpleCategorySeriesRule());
                $ret.add(new SubCollectionsRule());
                return $ret;
            })());
        }
        get b4() {
            return this.get_b4();
        }
        f1(a, b) {
            let c = typeCast(HorizontalAnchoredCategorySeries.$, a);
            if (c != null) {
                c.o4 = this.o6;
                c.l2 = this.ai(a, b);
            }
        }
        ra(a) {
            this.rb((b, c) => a(b));
        }
        rb(a) {
            if (this.dataChart == null) {
                return;
            }
            for (let b = 0; b < this.dataChart.series.count; b++) {
                let c = typeCast(HorizontalAnchoredCategorySeries.$, this.dataChart.series._inner[b]);
                if (c == null) {
                    continue;
                }
                a(c, b);
            }
        }
        id() {
            return this.xAxis;
        }
        ie() {
            return this.yAxis;
        }
        pf() {
            return this.ar(30);
        }
        pg() {
            return this.ar(31);
        }
        b1(a, b) {
            let c = super.b1(a, b);
            if (c != null) {
                let d = new List$1(Series.$, 0);
                if (this.pl) {
                    d.add(this.pf());
                }
                if (this.pm) {
                    d.add(this.pg());
                }
                for (let e = 0; e < d.count; e++) {
                    let f = d._inner[e];
                    f.name = a + getInstanceType(f).typeName;
                    c.add(f);
                }
            }
            return c;
        }
        hq(a, b, c) {
            super.hq(a, b, c);
            if (this.v.dataSeries.count > 0) {
                if (stringIsNullOrEmpty(this.ea)) {
                    this.ac.setXMemberPath(a, c.getMemberPathFor(16));
                }
                if (stringIsNullOrEmpty(this.ec)) {
                    this.ac.setYMemberPath(a, c.getMemberPathFor(0));
                }
                if (stringIsNullOrEmpty(this.d6)) {
                    this.ac.setLabelMemberPath(a, c.getMemberPathFor(0));
                }
                if (stringIsNullOrEmpty(this.d3)) {
                    this.ac.setContentMemberPath(a, c.getMemberPathFor(0));
                }
            }
        }
        g3(a, b, c) {
            super.g3(a, b, c);
            switch (a) {
                case "ChartType":
                    this.hl();
                    break;
                case "MarkerCollisionAvoidance":
                    this.ra((d) => d.o4 = this.o6);
                    break;
                case "IsTransitionInEnabled":
                    this.ra((d) => d.n2 = this.ps);
                    break;
                case "TransitionInMode":
                    this.ra((d) => d.nl = this.o8);
                    break;
                case "TransitionInSpeedType":
                    this.ra((d) => d.bp = this.pi);
                    break;
                case "XAxisInterval":
                    this.xAxis.ld = this.qa;
                    break;
                case "XAxisMinorInterval":
                    this.xAxis.le = this.qb;
                    break;
                case "XAxisGap":
                    this.xAxis.jv = this.p9;
                    break;
                case "XAxisOverlap":
                    this.xAxis.j2 = this.qc;
                    break;
                case "YAxisInterval":
                    this.yAxis.kf = this.qf;
                    break;
                case "YAxisIsLogarithmic":
                    this.yAxis.j0 = this.pu;
                    break;
                case "YAxisLogarithmBase":
                    this.yAxis.kn = this.qm;
                    break;
                case "YAxisMinimumValue":
                    this.yAxis.kj = this.qh;
                    break;
                case "YAxisMaximumValue":
                    this.yAxis.ki = this.qg;
                    break;
                case "YAxisMinorInterval":
                    this.yAxis.kk = this.qi;
                    break;
                case "NegativeBrushes":
                case "NegativeOutlines":
                    this.rb((d, e) => {
                        if (d.cz) {
                            d.jj(ArrayExtension.getModulus$1(Brush.$, this.o1, e), ArrayExtension.getModulus$1(Brush.$, this.o2, e));
                        }
                    });
                    break;
                case "YAxisAbbreviateLargeNumbers":
                    this.nn((d) => d.jv = this.pt);
                    break;
                case "IsCategoryHighlightingEnabled":
                case "IsItemHighlightingEnabled":
                    this.hl();
                    break;
            }
        }
    }
    CategoryChart.$t = /*@__PURE__*/ markType(CategoryChart, 'CategoryChart', XYChart.$);
    return CategoryChart;
})();
//# sourceMappingURL=CategoryChart.js.map
