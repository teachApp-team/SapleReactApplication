/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { ScatterBase } from "./ScatterBase";
import { UnknownValuePlotting_$type } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { Point_$type, typeCast, Number_$type, enumGetBox, markType, markDep } from "igniteui-react-core";
import { OwnedPoint } from "./OwnedPoint";
import { ScatterFrame } from "./ScatterFrame";
import { ScatterLineSeriesView } from "./ScatterLineSeriesView";
import { PathGeometry } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { ScalerParams } from "./ScalerParams";
import { Clipper } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { RectUtil } from "igniteui-react-core";
import { PolyLineSegment } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { PathFigureCollection } from "igniteui-react-core";
import { Flattener } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { boxArray$1, arrayShallowClone } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let ScatterLineSeries = /*@__PURE__*/ (() => {
    class ScatterLineSeries extends ScatterBase {
        constructor() {
            super();
            this.ab = ScatterLineSeries.$;
            this.nd = new ScatterFrame();
            this.nf = new ScatterFrame();
            this.nc = new ScatterFrame();
            let a = (b, c, d) => {
                let e = this.bz.indexOf(b.a);
                if (e == -1 || e == 0) {
                    return b;
                }
                let f = this.bz.item(e - 1);
                let g;
                if (!((() => { let h = c.g.tryGetValue(f, g); g = h.p1; return h.ret; })())) {
                    return b;
                }
                return g;
            };
            this.nd.o = a;
            this.nf.o = a;
            this.nc.o = a;
        }
        bf() {
            return new ScatterLineSeriesView(this);
        }
        dh(a, b) {
            if (this.l5(a, b)) {
                return true;
            }
            if (this.o2(a, b)) {
                return true;
            }
            return false;
        }
        o2(a, b) {
            let c = this.bi;
            let d = c.da;
            return this.di(a, b, d.ak);
        }
        n6(a, b) {
            super.n6(a, b);
            a.m.clear();
            a.u.clear();
            let c = b.bs;
            let d = b.br;
            let e = this.getEffectiveViewport1(b);
            let f = this.eu * this.eu;
            let g = 0;
            if (this.nh != null) {
                g = this.nh.count;
            }
            if (this.nj != null) {
                g = Math.min(this.nj.count, g);
            }
            let h = new ScalerParams(0, c, d, this.m8.d, e);
            let i = ((() => {
                let $ret = new ScalerParams(0, c, d, this.m8.e, e);
                $ret.b = this.eh();
                return $ret;
            })());
            let j = arrayShallowClone(this.nh.asArray());
            let k = arrayShallowClone(this.nj.asArray());
            this.xAxis.gs(boxArray$1(j), 0, j.length, h);
            this.yAxis.gs(boxArray$1(k), 0, k.length, i);
            let l = d.top - 10;
            let m = d.bottom + 10;
            let n = d.left - 10;
            let o = d.right + 10;
            let p = ((() => {
                let $ret = new Clipper(1, n, m, o, l, false);
                $ret.i = a.m;
                return $ret;
            })());
            for (let q = 0; q < g;) {
                let r = q;
                ++q;
                if (g > this.no) {
                    while (q < g) {
                        let s = j[q] - j[r];
                        let t = k[q] - k[r];
                        let u = s * s + t * t;
                        if (u >= f) {
                            break;
                        }
                        ++q;
                    }
                    p.j(this.o9(j, k, r, q - 1));
                }
                else {
                    let v = new OwnedPoint();
                    v.c = { $type: Point_$type, x: j[r], y: k[r] };
                    v.a = this.bz.item(r);
                    if (!a.u.containsKey(v.a)) {
                        a.u.addItem(v.a, v);
                    }
                }
            }
            if (g > this.no) {
                p.i = null;
            }
        }
        o9(a, b, c, d) {
            if (c == d) {
                return { $type: Point_$type, x: a[c], y: b[c] };
            }
            let e = 0;
            let f = 0;
            let g = (d - c + 1);
            for (let h = c; h <= d; ++h) {
                e += a[h];
                f += b[h];
            }
            return { $type: Point_$type, x: e / g, y: f / g };
        }
        of(a, b) {
            b.c0(false);
            super.of(a, b);
            let c = new Rect(0, b.br.left, b.br.top, b.br.width, b.br.height);
            c = RectUtil.t(c, this.ey, this.ey);
            this.oa(a, new Clipper(0, c, false));
            let d = typeCast(ScatterLineSeriesView.$, b);
            this.o7(d.da, a.m.count, (e) => a.m._inner[e].x, (e) => a.m._inner[e].y, this.o1, this.eu);
        }
        o7(a, b, c, d, e, f) {
            let g = new PathGeometry();
            a.ak = g;
            g.c = new PathFigureCollection();
            let h = new List$1(PolyLineSegment.$, 0);
            let i = 0;
            for (let j = 0; j < b; j++) {
                if (isNaN_(c(j)) || isNaN_(d(j))) {
                    let k = j - i;
                    if (k > 0) {
                        if (e == 1 || h.count == 0) {
                            let l = new PolyLineSegment();
                            h.add(l);
                        }
                        this.o6(h._inner[h.count - 1]._points, i, j - 1, c, d, f);
                    }
                    i = j + 1;
                }
            }
            if (e == 1 || h.count == 0) {
                let m = new PolyLineSegment();
                h.add(m);
            }
            this.o6(h._inner[h.count - 1]._points, i, b - 1, c, d, f);
            for (let n = 0; n < h.count; n++) {
                let o = h._inner[n];
                if (o._points.count > 0) {
                    let p = ((() => {
                        let $ret = new PathFigure();
                        $ret.startPoint = o._points._inner[0];
                        return $ret;
                    })());
                    p._segments.add(o);
                    g.c.add(p);
                }
            }
        }
        o3(a, b, c, d, e, f) {
            let g = new List$1(Number_$type, 0);
            let h = d;
            let i = e;
            let j = i - h + 1;
            while (j > 0) {
                if (j <= 512) {
                    Flattener.c(g, b, c, h, i, f);
                    h = i + 1;
                }
                else {
                    let k = h + 512 - 1;
                    Flattener.c(g, b, c, h, k, f);
                    h = k + 1;
                }
                j = i - h + 1;
            }
            return g;
        }
        o6(a, b, c, d, e, f) {
            if (c > -1) {
                let g = this.eu;
                let h = this.o3(new List$1(Number_$type, 0), d, e, b, c, g);
                let i;
                for (let j = 0; j < h.count; j++) {
                    i = h.item(j);
                    a.add({ $type: Point_$type, x: d(i), y: e(i) });
                }
            }
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case ScatterLineSeries.$$p[0]:
                    this.je(false);
                    this.il();
                    break;
            }
        }
    }
    ScatterLineSeries.$t = /*@__PURE__*/ markType(ScatterLineSeries, 'ScatterLineSeries', ScatterBase.$);
    ScatterLineSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, ScatterLineSeries, 'raisePropertyChanged', ['UnknownValuePlotting:o1:o8', [UnknownValuePlotting_$type, /*@__PURE__*/ enumGetBox(UnknownValuePlotting_$type, 1)]]);
    return ScatterLineSeries;
})();
//# sourceMappingURL=ScatterLineSeries.js.map
