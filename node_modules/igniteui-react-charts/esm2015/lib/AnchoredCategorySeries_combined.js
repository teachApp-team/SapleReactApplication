/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { CategorySeries } from "./CategorySeries";
import { IIsCategoryBased_$type } from "./IIsCategoryBased";
import { IHasSingleValueCategory_$type } from "./IHasSingleValueCategory";
import { IHasCategoryTrendline_$type } from "./IHasCategoryTrendline";
import { ITrendLineSeries_$type } from "./ITrendLineSeries";
import { IAnchoredCategorySeriesInteractionManager_$type } from "./IAnchoredCategorySeriesInteractionManager";
import { DVContainer } from "igniteui-react-core";
import { enumGetBox, typeCast, Point_$type, markType, markDep } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { Series } from "./Series";
import { TrendLineType_$type } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { PenLineCap_$type } from "igniteui-react-core";
import { DoubleCollection } from "igniteui-react-core";
import { CategoryFrame } from "./CategoryFrame";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { ICategoryScaler_$type } from "./ICategoryScaler";
import { IScaler_$type } from "./IScaler";
import { CategorySeriesView } from "./CategorySeriesView";
import { CategorySeriesMarkerCollisionAvoidance_$type } from "./CategorySeriesMarkerCollisionAvoidance";
import { ConsolidatedItemHitTestBehavior_$type } from "./ConsolidatedItemHitTestBehavior";
import { CategoryFramePreparer } from "./CategoryFramePreparer";
import { Rect } from "igniteui-react-core";
import { ISortingAxis_$type } from "./ISortingAxis";
import { IFastItemsSource_$type } from "igniteui-react-core";
import { NumericAxisBase } from "./NumericAxisBase";
import { CategoryBucketCalculator } from "./CategoryBucketCalculator";
import { AxisRange } from "./AxisRange";
import { NumericYAxis } from "./NumericYAxis";
import { ScalerParams } from "./ScalerParams";
import { CategoryMarkerManager } from "./CategoryMarkerManager";
import { CollisionAvoider } from "./CollisionAvoider";
import { NonCollisionAvoider } from "./NonCollisionAvoider";
import { PropertyMetadata } from "igniteui-react-core";
import { truncate, isNaN_ } from "igniteui-react-core";
import { CategoryTrendLineManagerFactory } from "./CategoryTrendLineManagerFactory";
/**
 * @hidden
 */
export let AnchoredCategorySeries = /*@__PURE__*/ (() => {
    class AnchoredCategorySeries extends CategorySeries {
        constructor() {
            super();
            this.o6 = null;
            this.pa = false;
            this.o8 = null;
            this.o3 = null;
            this.pd = null;
            this.nf = new CategoryFramePreparer(1, this, this.nj, this, this, this.nj.cn);
        }
        get o7() {
            if (this.o6 == null) {
                this.o6 = DVContainer.instance.createInstance(IAnchoredCategorySeriesInteractionManager_$type, () => this.b2.n);
            }
            return this.o6;
        }
        getHostReferenceValue() {
            return this.eh();
        }
        bf() {
            let a = new AnchoredCategorySeriesView(this);
            return a;
        }
        iv(a) {
            super.iv(a);
            this.o2 = a;
        }
        fs(a, b) {
            let c = this.gv(b);
            if (c == AnchoredCategorySeries.$$p[2]) {
                return this.ft(a, b, this.ph);
            }
            return super.fs(a, b);
        }
        get valueColumn() {
            return this.o8;
        }
        set valueColumn(a) {
            if (this.o8 != a) {
                let b = this.o8;
                this.o8 = a;
                if (!this.pa) {
                    this.raisePropertyChanged("ValueColumn", b, this.o8);
                }
            }
        }
        get pz() {
            return this.c(AnchoredCategorySeries.po);
        }
        set pz(a) {
            this.h(AnchoredCategorySeries.po, a);
        }
        c9(a) {
            let b = new Rect(0, 0, 0, 1, 1);
            let c = this.fetchXAxis();
            let d = this.fetchYAxis();
            let e = this.lt(this.bi);
            let f = c != null ? this.nf.r(typeCast(ICategoryScaler_$type, c), b, b, e) : 0;
            return this.o7.c$a(this, this.valueColumn, c, d, f, a);
        }
        oz(a, b, c) {
            if (b < a || a < 0 || a > this.valueColumn.count || b < 0 || b > this.valueColumn.count || c == null) {
                return null;
            }
            let d = new Array((b - a) + 1);
            let e = c.cf;
            let f = null;
            if (e) {
                f = c.i$b;
            }
            for (let g = a; g <= b; g++) {
                let h = g;
                if (e) {
                    h = f._inner[h];
                }
                d[g - a] = this.bz.item(g);
            }
            return d;
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            if (this.o2.cz && this.o2.cy.g$b(a, b, c, d)) {
                this.je(false);
                this.il();
            }
            switch (b) {
                case "FastItemsSource":
                    if (typeCast(IFastItemsSource_$type, c) != null) {
                        c.deregisterColumn(this.valueColumn);
                        this.valueColumn = null;
                    }
                    if (typeCast(IFastItemsSource_$type, d) != null) {
                        this.valueColumn = this.bw(this.ph);
                    }
                    let e = typeCast(NumericAxisBase.$, this.fetchYAxis());
                    if (e != null && !e.cn()) {
                        this.o2.cn.g(this.eu);
                        this.je(false);
                    }
                    break;
                case AnchoredCategorySeries.$$p[2]:
                    if (this.bz != null) {
                        this.bz.deregisterColumn(this.valueColumn);
                        this.valueColumn = this.bw(this.ph);
                    }
                    this.pd = this.ph;
                    break;
                case "ValueColumn":
                    if (this.o2.cz) {
                        this.o2.cy.g$i();
                    }
                    let f = typeCast(NumericAxisBase.$, this.fetchYAxis());
                    if (f != null && !f.cn()) {
                        this.o2.cn.g(this.eu);
                        this.je(false);
                    }
                    this.pn();
                    this.jr();
                    break;
                case "TrendLineBrush":
                    this.jp();
                    break;
                case "ErrorBarSettings":
                    this.je(false);
                    break;
                case "TrendLineType":
                    this.il();
                    break;
                case AnchoredCategorySeries.$$p[1]:
                    this.je(false);
                    break;
            }
        }
        an(a) {
            if (this.valueColumn == null || this.valueColumn.count == 0) {
                return null;
            }
            if (a == this.fetchXAxis()) {
                return new AxisRange(0, this.valueColumn.count - 1);
            }
            if (a == this.fetchYAxis()) {
                return new AxisRange(this.valueColumn.minimum, this.valueColumn.maximum);
            }
            return null;
        }
        hz(a, b, c, d) {
            switch (a) {
                case 4:
                case 1:
                case 0:
                    this.o2.cn.g(this.eu);
                    break;
            }
            if (this.o2.cz) {
                this.o2.cy.g$e(a, b, c, d);
            }
            this.pn();
            this.jr();
        }
        oa() {
            return this.pb(this.nj);
        }
        pb(a) {
            let b = 0;
            let c = a.bs;
            let d = a.br;
            let e = this.getEffectiveViewport1(a);
            let f = typeCast(NumericYAxis.$, this.fetchYAxis());
            if (!c.isEmpty && !d.isEmpty && f != null) {
                let g = new ScalerParams(0, c, d, f.ca, e);
                if (f.ch) {
                    g.b = this.eh();
                }
                b = f.dy(f.kl, g);
            }
            return b;
        }
        pm(a, b, c) {
            let d = this.pb(c);
            if (a.count > 0) {
                let e = d;
                a.add({ $type: Point_$type, x: a._inner[a.count - 1].x, y: e });
                a.add({ $type: Point_$type, x: a._inner[0].x, y: e });
            }
        }
        o0(a, b, c, d) {
            return this.o1(a, b, c, d, false);
        }
        o1(a, b, c, d, e) {
            return CategorySeries.m5(a, b, c, d, e);
        }
        dw(a, b, c) {
            let d = super.dw(a, b, c);
            let e = c;
            if (this.valueColumn == null || this.valueColumn.count == 0 || e.cn.d < 1) {
                d = false;
            }
            return d;
        }
        hw(a, b) {
            super.hw(a, b);
            let c = b;
            c.ct();
            if (c.cz) {
                c.cy.g$d();
            }
        }
        op(a, b) {
            super.op(a, b);
            this.ng(b).d(a, b);
        }
        os(a, b) {
            super.os(a, b);
            let c = typeCast(AnchoredCategorySeriesView.$, b);
            c.b0 = true;
            if (c.cz) {
                c.cy.g$g(a.p);
            }
            if (this.l4()) {
                CategoryMarkerManager.b(this, a.m, b.cq, this.l6);
                this.om(b, a);
                b.cj();
            }
            this.pj(a, b);
        }
        jd(a, b, c, d, e) {
            super.jd(a, b, c, d, e);
            let f = this.a0.a$h.item(d);
            let g = f;
            g.cn.g(this.eu);
            f.ay(c);
            if (this.cc(g)) {
                return;
            }
            if (this.o3 == null) {
                this.o3 = new CategoryFrame(3);
            }
            this.o3.u();
            this.op(this.o3, g);
            this.os(this.o3, g);
        }
        pj(a, b) {
        }
        jp() {
            super.jp();
            if (this.fh < 0) {
                return;
            }
            this.o2.c3();
            if (this.trendLineBrush != null) {
                this.o2.c1();
            }
            else {
                this.o2.c0();
            }
        }
        fv(a, b) {
            if (this.o2.cz && a == this.o2.cy.g$j) {
                return null;
            }
            return super.fv(a, b);
        }
        get currentCategoryMode() {
            return this.preferredCategoryMode(typeCast(CategoryAxisBase.$, this.fetchXAxis()));
        }
        get scaler() {
            return typeCast(ICategoryScaler_$type, this.fetchXAxis());
        }
        get yScaler() {
            return typeCast(IScaler_$type, this.fetchYAxis());
        }
        get bucketizer() {
            return this.o2.cn;
        }
        get currentMode2Index() {
            return this.od();
        }
        provideCollisionDetector() {
            if (this.o4 == 1) {
                return new CollisionAvoider();
            }
            return NonCollisionAvoider.a;
        }
        get trendlinePreparer() {
            return this.o2.cz ? this.o2.cy : null;
        }
        h5(a) {
            super.h5(a);
            if (this.o2.cz) {
                this.a2.exportTrendlineData(this, a, this.o2.cy.g$j);
            }
        }
        fp(a) {
            let b = this.fetchXAxis();
            let c = this.fetchYAxis();
            return this.o7.c$b(this, a, this.ob(this.bi), this.valueColumn, b, c, this.o5 == 1, (d) => super.fp(d));
        }
        get mayContainUnknowns() {
            return this.valueColumn == null || this.valueColumn.mayContainUnknowns;
        }
        eh() {
            return Series.ei(this.valueColumn, typeCast(ISortingAxis_$type, this.fetchXAxis()));
        }
        ao() {
            if (this.valueColumn == null) {
                return null;
            }
            let a = this.na();
            let b = new ScalerParams(0, this.bs.mr, this.bs.m5, a.ca, this.getEffectiveViewport());
            let c = (a.d1(this.bs.m5.left, b));
            let d = (a.d1(this.bs.m5.right, b));
            let e = null;
            if (a.cf) {
                e = a;
                c = e.i$f(c);
                d = e.i$f(d);
            }
            else {
                c = Math.floor(c);
                d = Math.ceil(d);
            }
            if (isNaN_(c) || isNaN_(d)) {
                return null;
            }
            c = Math.max(0, Math.min(this.valueColumn.count - 1, c));
            d = Math.max(0, Math.min(this.valueColumn.count - 1, d));
            let f = 1.7976931348623157E+308;
            let g = -1.7976931348623157E+308;
            for (let h = truncate(c); h <= truncate(d); h++) {
                let i = h;
                if (e != null) {
                    i = e.i$b._inner[h];
                }
                f = Math.min(f, this.valueColumn.item(i));
                g = Math.max(g, this.valueColumn.item(i));
            }
            return new AxisRange(f, g);
        }
        pn() {
            this.d8 = this.valueColumn == null || this.valueColumn.count == 0 ? NaN : this.valueColumn.item(this.valueColumn.count - 1);
        }
        get useHighMarkerFidelity() {
            return this.n6;
        }
    }
    AnchoredCategorySeries.$t = /*@__PURE__*/ markType(AnchoredCategorySeries, 'AnchoredCategorySeries', CategorySeries.$, [IIsCategoryBased_$type, IHasSingleValueCategory_$type, IHasCategoryTrendline_$type, ITrendLineSeries_$type]);
    AnchoredCategorySeries.po = /*@__PURE__*/ DependencyProperty.i("ActualTrendLineBrush", Brush.$, AnchoredCategorySeries.$, /*@__PURE__*/ new PropertyMetadata(2, null, (a, b) => a.raisePropertyChanged("ActualTrendLineBrush", b.oldValue, b.newValue)));
    AnchoredCategorySeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, AnchoredCategorySeries, 'raisePropertyChanged', ['ConsolidatedItemHitTestBehavior:o5:pp', [ConsolidatedItemHitTestBehavior_$type, /*@__PURE__*/ enumGetBox(ConsolidatedItemHitTestBehavior_$type, 0)], 'MarkerCollisionAvoidance:o4:pq', [CategorySeriesMarkerCollisionAvoidance_$type, /*@__PURE__*/ enumGetBox(CategorySeriesMarkerCollisionAvoidance_$type, 1)], 'ValueMemberPath:ph:py', [2, null], 'TrendLineType::pw', [TrendLineType_$type, /*@__PURE__*/ enumGetBox(TrendLineType_$type, 0)], 'TrendLineThickness::pv', [1, 1.5], 'TrendLinePeriod::pu', [1, 7], 'TrendLineBrush::pr', [Brush.$, null], 'TrendLineZIndex:pc:px', [1, 1001], 'TrendLineDashArray:p0:ps', [DoubleCollection.$], 'TrendLineDashCap:p1:pt', [PenLineCap_$type, /*@__PURE__*/ enumGetBox(PenLineCap_$type, 0)]]);
    return AnchoredCategorySeries;
})();
/**
 * @hidden
 */
export let AnchoredCategoryBucketCalculator = /*@__PURE__*/ (() => {
    class AnchoredCategoryBucketCalculator extends CategoryBucketCalculator {
        constructor(a) {
            super(a);
            this.i = null;
            this.h = null;
            this.j = 0;
            this.i = a;
        }
        getBucketWithoutUnknowns(a) {
            let b = this.h;
            let c = this.j;
            let d = a * this.d;
            let e = d + this.d - 1;
            let f = c - 1;
            d = d < f ? d : f;
            e = e < f ? e : f;
            let g = 1.7976931348623157E+308;
            let h = -1.7976931348623157E+308;
            let i = true;
            for (let j = d; j <= e; ++j) {
                let k = b[j];
                g = g < k ? g : k;
                h = h > k ? h : k;
                i = false;
            }
            if (!i) {
                return [0.5 * (d + e), g, h];
            }
            return [0.5 * (d + e), NaN, NaN];
        }
        getBucket(a) {
            let b = this.h;
            let c = this.j;
            let d = a * this.d;
            let e = d + this.d - 1;
            let f = c - 1;
            d = d < f ? d : f;
            e = e < f ? e : f;
            let g = 0;
            let h = 0;
            let i = true;
            for (let j = d; j <= e; ++j) {
                let k = b[j];
                if (!i) {
                    if (!isNaN_(k)) {
                        g = g < k ? g : k;
                        h = h > k ? h : k;
                    }
                }
                else {
                    if (!isNaN_(k)) {
                        g = k;
                        h = k;
                        i = false;
                    }
                }
            }
            if (!i) {
                return [0.5 * (d + e), g, h];
            }
            return [0.5 * (d + e), NaN, NaN];
        }
        cacheValues() {
            this.j = this.i.cw.valueColumn.count;
            this.h = this.i.cw.valueColumn.asArray();
        }
        unCacheValues() {
            this.h = null;
        }
    }
    AnchoredCategoryBucketCalculator.$t = /*@__PURE__*/ markType(AnchoredCategoryBucketCalculator, 'AnchoredCategoryBucketCalculator', CategoryBucketCalculator.$);
    return AnchoredCategoryBucketCalculator;
})();
/**
 * @hidden
 */
export let AnchoredCategorySeriesView = /*@__PURE__*/ (() => {
    class AnchoredCategorySeriesView extends CategorySeriesView {
        constructor(a) {
            super(a);
            this.cw = null;
            this.cx = null;
            this.cw = a;
        }
        get cy() {
            if (this.cx == null) {
                this.cx = CategoryTrendLineManagerFactory.a(this.cx, this.e.ap(), this.e.jy, this.e, this.e.b2);
            }
            return this.cx;
        }
        set cy(a) {
            this.cx = a;
        }
        get cz() {
            return this.cx != null;
        }
        c3() {
            this.cw.pz = null;
        }
        c1() {
            this.cw.pz = this.cw.trendLineBrush;
        }
        c0() {
            this.cw.pz = this.cw.k4;
        }
        co() {
            return new AnchoredCategoryBucketCalculator(this);
        }
        c2() {
            this.cn.cacheValues();
        }
        c4() {
            this.cn.unCacheValues();
        }
        c5(a) {
            let b = this.cq.item(a);
            return this.cm(b);
        }
        a2(a, b) {
            if (a.d) {
                if (this.cw.trendLineType != 0 && !b) {
                    let c = this.cy.g$j;
                    c.ac = this.cw.trendLineThickness;
                    c._stroke = this.cw.pz;
                    c.ai = this.cw.p0;
                    c.ad = this.cw.p1;
                    a.u(c);
                }
            }
            super.a2(a, b);
        }
        getDefaultTooltipTemplate() {
            return this.cw.o7.c$c(this.e, this.cw.ph);
        }
    }
    AnchoredCategorySeriesView.$t = /*@__PURE__*/ markType(AnchoredCategorySeriesView, 'AnchoredCategorySeriesView', CategorySeriesView.$);
    return AnchoredCategorySeriesView;
})();
//# sourceMappingURL=AnchoredCategorySeries_combined.js.map
