import { IgrCalculatedColumn } from './igr-calculated-column';
import { FinancialCalculationDataSource as FinancialCalculationDataSource_internal } from "./FinancialCalculationDataSource";
/**
 * Represents the data contract between a financial series and the
 * decoupled calculation responsibilities which implement its mathmatical logic.
 * The FinancialCalculationDataSource contract represents the subset
 * of data which needs to be provided in order to test or run a calculation,
 * and its intentionally a subset of the information available to the series,
 * in order to make calculation strategies more easily testable and usable in isolation to
 * the financial series container.
*/
export declare class IgrFinancialCalculationDataSource {
    protected createImplementation(): FinancialCalculationDataSource_internal;
    protected _implementation: any;
    readonly i: FinancialCalculationDataSource_internal;
    private onImplementationCreated;
    constructor();
    protected _provideImplementation(i: any): void;
    readonly openColumn: number[];
    readonly highColumn: number[];
    readonly lowColumn: number[];
    readonly closeColumn: number[];
    readonly volumeColumn: number[];
    readonly indicatorColumn: any;
    /**
 * An enumerable list of typical prices provided by the series to use
 * in calculations.
*/
    typicalColumn: IgrCalculatedColumn;
    /**
     * And enumerable list of true range values provided by the series to use
     * in calculations.
    */
    trueRange: IgrCalculatedColumn;
    /**
     * An enumerable list of true low values provided by the series to use
     * in calculations.
    */
    trueLow: IgrCalculatedColumn;
    /**
     * The period to use when calculating, if applicable.
    */
    period: number;
    /**
     * The short period to use when calculating, if applicable.
    */
    shortPeriod: number;
    /**
     * The long period to use when calculating, if applicable.
    */
    longPeriod: number;
    /**
     * The count of the values in the series.
    */
    count: number;
    /**
     * The starting index from which to calculate
    */
    calculateFrom: number;
    /**
     * The number of items from the starting index from which to calculate
    */
    calculateCount: number;
    /**
     * If the calculation supports some sort of scaling factor,
     * this value will be used.
    */
    multiplier: number;
    /**
     * If the calculation determines the range of indicator values,
     * it will set the minimum and maximux properties.
     * This will contain the previous minimum value when the indicator
     * calculation is called again, in case this makes the update of the
     * value speedier.
    */
    minimumValue: number;
    /**
     * If the calculation determines the range of indicator values,
     * it will set the minimum and maximux properties.
     * This will contain the previous minimum value when the indicator
     * calculation is called again, in case this makes the update of the
     * value speedier.
    */
    maximumValue: number;
    /**
     * The calculation strategy should set this to true if it
     * specifes the minimum and maximum value properties.
    */
    specifiesRange: boolean;
    findByName(name: string): any;
}
