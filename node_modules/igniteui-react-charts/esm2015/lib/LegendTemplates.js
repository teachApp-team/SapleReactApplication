/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, typeCast, Point_$type, markType } from "igniteui-react-core";
import { DataTemplateRenderInfo } from "igniteui-react-core";
import { Series } from "./Series";
import { DataTemplate } from "igniteui-react-core";
import { LegendItemHelper } from "igniteui-react-core";
import { RenderingContext } from "igniteui-react-core";
import { Line } from "igniteui-react-core";
import { MarkerSeries } from "./MarkerSeries";
import { CanvasViewRenderer } from "igniteui-react-core";
import { DataTemplateMeasureInfo } from "igniteui-react-core";
import { Path } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { ArcSegment } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { isNaN_, isInfinity } from "igniteui-react-core";
/**
 * @hidden
 */
export let LegendTemplates = /*@__PURE__*/ (() => {
    class LegendTemplates extends Base {
        static d(a) {
            let b = a.data;
            let c = b.series;
            let d = c.legendItemBadgeTemplate;
            if (d == null) {
                d = LegendTemplates.ab(c.bj);
            }
            let e = c.fx;
            if (e == null) {
                e = "Series Title";
            }
            LegendItemHelper.d(a.context, a.xPosition, a.yPosition, a.availableWidth, a.availableHeight, a.data, e.toString(), d, a.passInfo, c.aw != null && c.aw.isFinancial, c.d8, c.et);
        }
        static resolveLegendItemTemplate(a) {
            switch (a) {
                case 0: return LegendTemplates.q;
                case 1: return LegendTemplates.r;
            }
            return LegendTemplates.q;
        }
        static b(a) {
            let b = a.data;
            let c = b.series;
            let d = c.legendItemBadgeTemplate;
            if (d == null) {
                d = LegendTemplates.ab(c.bj);
            }
            let e = b.itemLabel;
            if (e == null) {
                e = "Series Item";
            }
            LegendItemHelper.c(a.context, a.xPosition, a.yPosition, a.availableWidth, a.availableHeight, a.data, e.toString(), d, a.passInfo);
        }
        static h(a) {
            let b = a.data;
            let c = a.context;
            let d = b.series;
            if (b.itemBrush != null) {
                b.actualItemBrush = b.itemBrush;
            }
            else {
                b.actualItemBrush = d.k4;
            }
            let e = new RenderingContext(new CanvasViewRenderer(), c);
            let f = new Line();
            f.ak = 0;
            f.am = a.availableHeight / 2;
            f.al = a.availableWidth;
            f.an = a.availableHeight / 2;
            f.ac = d.ey;
            f._stroke = b.actualItemBrush;
            f.ai = d.lc;
            e.r(f);
            let g = typeCast(MarkerSeries.$, b.series);
            if (g != null && g.ml != null && g.ml.render != null) {
                b.outline = g.m0;
                b.thickness = 2;
                LegendTemplates.n(g.ml, a);
            }
        }
        static n(a, b) {
            let c = new DataTemplateMeasureInfo();
            c.passInfo = b.passInfo;
            c.width = 11;
            c.height = 11;
            c.data = b.data;
            c.context = b.context;
            c.renderContext = b.renderContext;
            let d = b.data;
            let e = d.actualItemBrush;
            let f = d.itemBrush;
            if (typeCast(Series.$, d.series) !== null) {
                if (d.itemBrush == null) {
                    let g = d.series;
                    d.actualItemBrush = g.k7();
                }
            }
            if (a.measure != null) {
                a.measure(c);
                if (isNaN_(c.width) || isInfinity(c.width) || c.width > 11) {
                    c.width = 11;
                }
                if (isNaN_(c.height) || isInfinity(c.height) || c.height > 11) {
                    c.height = 11;
                }
            }
            let h = new DataTemplateRenderInfo();
            h.passInfo = b.passInfo;
            h.availableWidth = c.width;
            h.availableHeight = c.height;
            h.xPosition = b.availableWidth / 2;
            h.yPosition = b.availableHeight / 2;
            h.data = b.data;
            h.context = b.context;
            h.renderContext = b.renderContext;
            a.render(h);
            d.itemBrush = f;
            d.actualItemBrush = e;
        }
        static p(a) {
            let b = null;
            if (typeCast(Series.$, a.series) !== null) {
                b = a.series;
            }
            if (a.itemBrush != null) {
                a.actualItemBrush = a.itemBrush;
            }
            else {
                if (b != null) {
                    a.actualItemBrush = b.k4;
                }
                else {
                    a.actualItemBrush = a.itemBrush;
                }
            }
        }
        static c(a) {
        }
        static a(a) {
        }
        static g(a) {
        }
        static m(a) {
            let b = a.data;
            let c = a.context;
            LegendTemplates.p(b);
            let d = new RenderingContext(new CanvasViewRenderer(), c);
            let e = new Path();
            let f = new PathGeometry();
            let g = new PathFigure();
            g._isFilled = true;
            let h = 0;
            if (typeCast(Series.$, b.series) !== null) {
                h = b.series.ey / 2;
                e.ac = b.series.ey;
                e._stroke = b.series.k5;
                e.ai = b.series.lc;
            }
            g._startPoint = { $type: Point_$type, x: h, y: 5 };
            g._segments.add(new LineSegment(0, { $type: Point_$type, x: h, y: 14 }));
            g._segments.add(new LineSegment(0, { $type: Point_$type, x: 11, y: 14 }));
            g._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.f = new Size(1, 5, 5);
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: 16, y: 9 };
                return $ret;
            })()));
            g._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: h }));
            g._segments.add(new LineSegment(0, { $type: Point_$type, x: 5, y: h }));
            g._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.f = new Size(1, 5, 5);
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: h, y: 5 };
                return $ret;
            })()));
            f.c.add(g);
            e.ak = f;
            e._fill = b.actualItemBrush;
            d.s(e);
            let i = typeCast(MarkerSeries.$, b.series);
            if (i != null && i.ml != null && i.ml.render != null) {
                if (typeCast(Series.$, b.series) !== null) {
                    b.outline = b.series.k5;
                }
                LegendTemplates.n(i.ml, a);
            }
        }
        static j(a) {
            let b = a.data;
            let c = a.context;
            LegendTemplates.p(b);
            let d = new Path();
            let e = new PathGeometry();
            let f = new PathFigure();
            let g = 0;
            if (typeCast(Series.$, b.series) !== null) {
                g = b.series.ey / 2;
                d.ac = b.series.ey;
                d._stroke = b.series.k5;
                d.ai = b.series.lc;
            }
            f._isFilled = true;
            f._startPoint = { $type: Point_$type, x: g, y: 5 };
            f._segments.add(new LineSegment(0, { $type: Point_$type, x: g, y: 14 }));
            f._segments.add(new LineSegment(0, { $type: Point_$type, x: 11, y: 14 }));
            f._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.f = new Size(1, 5, 5);
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: 16, y: 9 };
                return $ret;
            })()));
            f._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: g }));
            f._segments.add(new LineSegment(0, { $type: Point_$type, x: 5, y: g }));
            f._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.f = new Size(1, 5, 5);
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: g, y: 5 };
                return $ret;
            })()));
            e.c.add(f);
            d.ak = e;
            d._fill = b.actualItemBrush;
            let h = new RenderingContext(new CanvasViewRenderer(), c);
            h.s(d);
        }
        static i(a) {
            let b = a.data;
            let c = a.context;
            let d = b.series;
            if (b.itemBrush != null) {
                b.actualItemBrush = b.itemBrush;
            }
            else {
                b.actualItemBrush = d.k4;
            }
            let e = new Line();
            e.ak = 0;
            e.am = a.availableHeight / 2;
            e.al = a.availableWidth;
            e.an = a.availableHeight / 2;
            e.ac = d.ey;
            e.ai = d.lc;
            e._stroke = b.actualItemBrush;
            let f = new RenderingContext(new CanvasViewRenderer(), c);
            f.r(e);
        }
        static k(a) {
            let b = a.data;
            LegendTemplates.p(b);
            let c = typeCast(MarkerSeries.$, b.series);
            if (c != null && c.ml != null && c.ml.render != null) {
                if (typeCast(Series.$, b.series) !== null) {
                    b.outline = b.series.k8();
                }
                LegendTemplates.n(c.ml, a);
            }
        }
        static l(a) {
            let b = a.data;
            let c = a.context;
            let d = b.series;
            if (b.itemBrush != null) {
                b.actualItemBrush = b.itemBrush;
            }
            else {
                b.actualItemBrush = d.k4;
            }
            let e = new Path();
            let f = new PathGeometry();
            let g = new PathFigure();
            let h = 0;
            if (typeCast(Series.$, b.series) !== null) {
                h = b.series.ey / 2;
                e.ac = b.series.ey;
                e._stroke = b.series.k5;
                e.ai = b.series.lc;
            }
            g._isFilled = true;
            g._startPoint = { $type: Point_$type, x: h, y: 5 };
            g._segments.add(new LineSegment(0, { $type: Point_$type, x: h, y: 14 }));
            g._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: h }));
            g._segments.add(new LineSegment(0, { $type: Point_$type, x: 5, y: h }));
            g._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.f = new Size(1, 5, 5);
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: h, y: 5 };
                return $ret;
            })()));
            f.c.add(g);
            e.ak = f;
            e._fill = b.actualItemBrush;
            let i = new Path();
            let j = new PathGeometry();
            let k = new PathFigure();
            let l = 0;
            let m = null;
            if (typeCast(Series.$, b.series) !== null) {
                l = b.series.ey / 2;
                i.ac = b.series.ey;
                i._stroke = b.series.k5;
                m = b.series.la();
            }
            k._isFilled = true;
            k._startPoint = { $type: Point_$type, x: l, y: 14 };
            k._segments.add(new LineSegment(0, { $type: Point_$type, x: 11, y: 14 }));
            k._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.f = new Size(1, 5, 5);
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: 16, y: 9 };
                return $ret;
            })()));
            k._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: l }));
            j.c.add(k);
            i.ak = j;
            if (m != null) {
                i._fill = m;
            }
            let n = new RenderingContext(new CanvasViewRenderer(), c);
            n.s(e);
            n.s(i);
            let o = typeCast(MarkerSeries.$, b.series);
            if (o != null && o.ml != null && o.ml.render != null) {
                if (typeCast(Series.$, b.series) !== null) {
                    b.outline = b.series.k5;
                }
                LegendTemplates.n(o.ml, a);
            }
        }
        static e(a) {
            let b = a.data;
            let c = a.context;
            let d = b.series;
            if (b.itemBrush != null) {
                b.actualItemBrush = b.itemBrush;
            }
            else {
                b.actualItemBrush = d.k4;
            }
            let e = new Path();
            let f = new PathGeometry();
            let g = 0;
            if (typeCast(Series.$, b.series) !== null) {
                g = b.series.ey / 2;
                e.ac = b.series.ey;
                e._stroke = b.series.k5;
                e.ai = b.series.lc;
            }
            let h = new PathFigure();
            h._isFilled = true;
            h._startPoint = { $type: Point_$type, x: g, y: 5 };
            h._segments.add(new LineSegment(0, { $type: Point_$type, x: g, y: 14 }));
            h._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: g }));
            h._segments.add(new LineSegment(0, { $type: Point_$type, x: 5, y: g }));
            h._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.f = new Size(1, 5, 5);
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: g, y: 5 };
                return $ret;
            })()));
            f.c.add(h);
            e.ak = f;
            e._fill = b.actualItemBrush;
            let i = new Path();
            let j = new PathGeometry();
            let k = new PathFigure();
            let l = 0;
            let m = null;
            if (typeCast(Series.$, b.series) !== null) {
                i.ac = b.series.ey;
                i._stroke = b.series.k5;
                i.ai = b.series.lc;
                m = b.series.la();
            }
            k._isFilled = true;
            k._startPoint = { $type: Point_$type, x: l, y: 14 };
            k._segments.add(new LineSegment(0, { $type: Point_$type, x: 11, y: 14 }));
            k._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.f = new Size(1, 5, 5);
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: 16, y: 9 };
                return $ret;
            })()));
            k._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: l }));
            j.c.add(k);
            i.ak = j;
            if (m != null) {
                i._fill = m;
            }
            let n = new RenderingContext(new CanvasViewRenderer(), c);
            n.s(e);
            n.s(i);
        }
        static f(a) {
            let b = a.data;
            let c = a.context;
            let d = b.series;
            if (b.itemBrush != null) {
                b.actualItemBrush = b.itemBrush;
            }
            else {
                b.actualItemBrush = d.k4;
            }
            let e = new Path();
            let f = new PathGeometry();
            let g = new PathFigure();
            let h = 0;
            if (typeCast(Series.$, b.series) !== null) {
                h = b.series.ey / 2;
                e.ac = b.series.ey;
                e._stroke = b.series.k5;
                e.ai = b.series.lc;
            }
            g._isFilled = true;
            g._startPoint = { $type: Point_$type, x: h, y: 5 };
            g._segments.add(new LineSegment(0, { $type: Point_$type, x: h, y: 14 }));
            g._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: h }));
            g._segments.add(new LineSegment(0, { $type: Point_$type, x: 5, y: h }));
            g._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.f = new Size(1, 5, 5);
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: h, y: 5 };
                return $ret;
            })()));
            f.c.add(g);
            e.ak = f;
            e._fill = b.actualItemBrush;
            let i = new Path();
            let j = new PathGeometry();
            let k = new PathFigure();
            let l = 0;
            let m = null;
            if (typeCast(Series.$, b.series) !== null) {
                l = b.series.ey / 2;
                i.ac = b.series.ey;
                i._stroke = b.series.k5;
                i.ai = b.series.lc;
                m = b.series.la();
            }
            k._isFilled = true;
            k._startPoint = { $type: Point_$type, x: l, y: 14 };
            k._segments.add(new LineSegment(0, { $type: Point_$type, x: 11, y: 14 }));
            k._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.f = new Size(1, 5, 5);
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: 16, y: 9 };
                return $ret;
            })()));
            k._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: l }));
            j.c.add(k);
            i.ak = j;
            if (m != null) {
                i._fill = m;
            }
            let n = new RenderingContext(new CanvasViewRenderer(), c);
            n.s(e);
            n.s(i);
        }
        static o(a) {
            let b = a.data;
            let c = a.context;
            LegendTemplates.p(b);
            let d = typeCast(Series.$, b.series) !== null ? b.series : null;
            if (d != null) {
                b.outline = d.k5;
            }
            let e = new PathGeometry();
            let f = ((() => {
                let $ret = new PathFigure();
                $ret.isClosed = true;
                $ret.isFilled = true;
                return $ret;
            })());
            f._startPoint = { $type: Point_$type, x: 0, y: 0 };
            f._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: 0 }));
            f._segments.add(new LineSegment(0, { $type: Point_$type, x: 16, y: 16 }));
            f._segments.add(new LineSegment(0, { $type: Point_$type, x: 0, y: 16 }));
            f._segments.add(new LineSegment(0, { $type: Point_$type, x: 0, y: 0 }));
            e.c.add(f);
            let g = ((() => {
                let $ret = new Path();
                $ret.ak = e;
                $ret.fill = b.actualItemBrush;
                return $ret;
            })());
            let h = new RenderingContext(new CanvasViewRenderer(), c);
            h.s(g);
            h.r(((() => {
                let $ret = new Line();
                $ret.ak = 8;
                $ret.al = 8;
                $ret.am = 0;
                $ret.an = 16;
                $ret.stroke = b.outline;
                $ret.ac = 2;
                return $ret;
            })()));
        }
        static ab(a) {
            switch (a) {
                case 0: return LegendTemplates.u;
                case 1: return LegendTemplates.z;
                case 4: return LegendTemplates.x;
                case 6: return LegendTemplates.s;
                case 7: return LegendTemplates.t;
                case 2: return LegendTemplates.v;
                case 3: return LegendTemplates.w;
                case 5: return LegendTemplates.y;
                case 8: return LegendTemplates.aa;
            }
            return LegendTemplates.z;
        }
    }
    LegendTemplates.$t = /*@__PURE__*/ markType(LegendTemplates, 'LegendTemplates');
    LegendTemplates.q = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.c;
        $ret.render = LegendTemplates.d;
        return $ret;
    })());
    LegendTemplates.r = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.a;
        $ret.render = LegendTemplates.b;
        return $ret;
    })());
    LegendTemplates.u = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.c;
        $ret.render = LegendTemplates.h;
        return $ret;
    })());
    LegendTemplates.z = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.c;
        $ret.render = LegendTemplates.m;
        return $ret;
    })());
    LegendTemplates.x = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.c;
        $ret.render = LegendTemplates.k;
        return $ret;
    })());
    LegendTemplates.s = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.c;
        $ret.render = LegendTemplates.e;
        return $ret;
    })());
    LegendTemplates.t = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.c;
        $ret.render = LegendTemplates.f;
        return $ret;
    })());
    LegendTemplates.v = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.c;
        $ret.render = LegendTemplates.j;
        return $ret;
    })());
    LegendTemplates.w = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.c;
        $ret.render = LegendTemplates.i;
        return $ret;
    })());
    LegendTemplates.y = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.c;
        $ret.render = LegendTemplates.l;
        return $ret;
    })());
    LegendTemplates.aa = /*@__PURE__*/ ((() => {
        let $ret = new DataTemplate();
        $ret.measure = LegendTemplates.c;
        $ret.render = LegendTemplates.o;
        return $ret;
    })());
    return LegendTemplates;
})();
//# sourceMappingURL=LegendTemplates.js.map
