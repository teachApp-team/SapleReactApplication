/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, typeCast, markType } from "igniteui-react-core";
import { ICategorySeriesInteractionManager_$type } from "./ICategorySeriesInteractionManager";
import { ScalerParams } from "./ScalerParams";
import { ISortingAxis_$type } from "./ISortingAxis";
import { HighlightingInfo } from "./HighlightingInfo";
import { intDivide, truncate, isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let CategorySeriesInteractionManager = /*@__PURE__*/ (() => {
    class CategorySeriesInteractionManager extends Base {
        b$c(a, b) {
            let c = a.bi.bs;
            let d = a.bi.br;
            let e = a.ap();
            let f = a.getEffectiveViewport1(a.bi);
            let g = a.lr(a.bi);
            let h = -1;
            if (e != null && !c.isEmpty && !d.isEmpty) {
                let i = new ScalerParams(0, c, d, e.ca, f);
                let j = e.d1(g.left, i);
                let k = e.d1(g.right, i);
                let l = (b.x - c.left) / c.width;
                let m = j + (l * (k - j));
                if (e.categoryMode != 0) {
                    m -= 0.5;
                }
                h = m;
            }
            return h;
        }
        b$f(a, b) {
            let c = 0;
            if (a.c1) {
                c = a.fa(b);
                if (c == -1) {
                    return null;
                }
            }
            else if (b.x == 1 && a.bz != null) {
                c = a.bz.count - 1;
            }
            else {
                c = a.e8(b);
            }
            return c >= 0 && a.bz != null && c < a.bz.count ? a.bz.item(c) : null;
        }
        b$d(a, b) {
            let c = a.bi.bs;
            let d = a.bi.br;
            let e = a.getEffectiveViewport1(a.bi);
            if (c.isEmpty || d.isEmpty) {
                return -1;
            }
            if (isNaN_(b.x)) {
                return -1;
            }
            let f = a.ap();
            if (f == null) {
                return -1;
            }
            let g = typeCast(ISortingAxis_$type, f);
            let h = a.lr(a.bi);
            let i = new ScalerParams(0, c, d, f.ca, e);
            let j = 0;
            if (f.cd) {
                let k = (b.x - c.left) / c.width;
                let l = k * h.width + h.left;
                j = f.d1(l, i);
            }
            else {
                let m = f.d1(h.left, i);
                let n = f.d1(h.right, i);
                let o = (b.x - c.left) / c.width;
                j = m + ((n - m) * o);
            }
            let p = g.i$f(j);
            return p;
        }
        b$e(a, b, c) {
            let d = a.bi.br;
            let e = a.bi.bs;
            let f = a.ap();
            let g = 0;
            if (f.ch) {
                let h = (c.y - e.top) / e.height;
                g = h * d.height + d.top;
            }
            else {
                let i = (c.x - e.left) / e.width;
                g = i * d.width + d.left;
            }
            if (f.ca) {
                let j = b.count;
                let k = 0;
                for (k = j - 1; k >= 0; k--) {
                    let l = b._inner[k];
                    let m = null;
                    if (k > 0) {
                        m = b._inner[k - 1];
                    }
                    if (l[0] <= g && m == null || m[0] >= g) {
                        if (m != null) {
                            if (Math.abs(l[0] - g) < Math.abs(m[0] - g)) {
                                return k;
                            }
                            else {
                                return k - 1;
                            }
                        }
                        else {
                            return k;
                        }
                    }
                }
                return k;
            }
            else {
                let n = b.count;
                let o = 0;
                for (o = 0; o < n; o++) {
                    let p = b._inner[o];
                    let q = null;
                    if (o < n - 1) {
                        q = b._inner[o + 1];
                    }
                    if (p[0] <= g && q == null || q[0] >= g) {
                        if (q != null) {
                            if (Math.abs(p[0] - g) < Math.abs(q[0] - g)) {
                                return o;
                            }
                            else {
                                return o + 1;
                            }
                        }
                        else {
                            return o;
                        }
                    }
                }
                return o;
            }
        }
        b$a(a, b, c, d, e, f, g, h) {
            let i = a.bz.count;
            let j = a.ap();
            let k = -1;
            let l = -1;
            if (j.cf) {
                let m = this.b$e(a, b, g);
                k = m;
                l = m;
            }
            else {
                let n = a.e8(g);
                k = truncate(Math.floor((intDivide(n, e)))) * e;
                l = k + (e - 1);
            }
            if (h != null && h.f == k && h.e == l) {
                return h;
            }
            let o = new HighlightingInfo();
            o.b = a;
            o.f = k;
            o.e = l;
            return o;
        }
        b$b(a, b, c, d, e, f) {
            let g = a.lh(e);
            let h = b;
            if (h == null) {
                return null;
            }
            let i = h.count;
            if (i == 0) {
                return null;
            }
            let j = h._inner[0].al;
            if (a.isVertical) {
                let k = c._inner[h._inner[0].al][0];
                let l = (g.y - k) * (g.y - k);
                let m;
                for (let n = 0; n < i; n++) {
                    k = c._inner[h._inner[n].al][0];
                    m = (g.y - k) * (g.y - k);
                    if (m <= l) {
                        l = m;
                        j = h._inner[n].al;
                    }
                }
            }
            else {
                let o = c._inner[h._inner[0].al][0];
                let p = (g.x - o) * (g.x - o);
                let q;
                for (let r = 0; r < i; r++) {
                    o = c._inner[h._inner[r].al][0];
                    q = (g.x - o) * (g.x - o);
                    if (q <= p) {
                        p = q;
                        j = h._inner[r].al;
                    }
                }
            }
            let s = new HighlightingInfo();
            s.b = a;
            s.c = true;
            s.f = j;
            s.e = s.f;
            if (f != null && f.f == s.f && f.e == s.e) {
                return f;
            }
            return s;
        }
    }
    CategorySeriesInteractionManager.$t = /*@__PURE__*/ markType(CategorySeriesInteractionManager, 'CategorySeriesInteractionManager', Base.$, [ICategorySeriesInteractionManager_$type]);
    return CategorySeriesInteractionManager;
})();
//# sourceMappingURL=CategorySeriesInteractionManager.js.map
