/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AnnotationLayer } from "./AnnotationLayer";
import { Brush } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { Series } from "./Series";
import { Thickness } from "igniteui-react-core";
import { Visibility_$type } from "igniteui-react-core";
import { CrosshairLayerFrame } from "./CrosshairLayerFrame";
import { List$1 } from "igniteui-react-core";
import { Axis } from "./Axis";
import { Dictionary$2 } from "igniteui-react-core";
import { Pool$1 } from "igniteui-react-core";
import { AxisAnnotation } from "./AxisAnnotation";
import { Number_$type, enumGetBox, fromEnum, Point_$type, markType, markDep, runOn } from "igniteui-react-core";
import { AxisAnnotationFrameManager } from "./AxisAnnotationFrameManager";
import { Tuple$2 } from "igniteui-react-core";
import { Path } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
import { AnnotationLayerView } from "./AnnotationLayerView";
import { TranslateTransform } from "igniteui-react-core";
import { LineGeometry } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
/**
 * @hidden
 */
export let CrosshairLayer = /*@__PURE__*/ (() => {
    class CrosshairLayer extends AnnotationLayer {
        constructor() {
            super();
            this.xAxisAnnotationFormatLabel = null;
            this.yAxisAnnotationFormatLabel = null;
            this.nf = null;
            this.ne = null;
            let a = new CrosshairLayerFrame();
            let b = new CrosshairLayerFrame();
            let c = new CrosshairLayerFrame();
            let d = this.fi / 1000;
            this.l3 = a;
            this.l2 = b;
            this.l4 = c;
            this.ab = CrosshairLayer.$;
        }
        bf() {
            return new CrosshairLayerView(this);
        }
        iv(a) {
            super.iv(a);
            this.m7 = a;
        }
        m9() {
            return this.xAxisAnnotationFormatLabel != null;
        }
        na() {
            return this.yAxisAnnotationFormatLabel != null;
        }
        get pj() {
            return new Thickness(1, this.nh, this.nj, this.ni, this.ng);
        }
        get pk() {
            return new Thickness(1, this.nm, this.no, this.nn, this.nl);
        }
        mm(a, b) {
            if (this.m8 == null || this.m8 == a) {
                if (!this.aq.c) {
                    this.je(b);
                }
            }
        }
        mo(a, b) {
            super.mo(a, b);
            let c = a;
            let d = this.nd;
            let e = this.nc;
            c.ad.clear();
            c.ae.clear();
            c.ac.clear();
            c.af.clear();
            AxisAnnotationFrameManager.b(c);
            if (this.l9(this.m8)) {
                this.oj(this.m8, c, d, e);
            }
            else {
                for (let f of fromEnum(this.bs.series)) {
                    if (this.l9(f)) {
                        this.oj(f, c, d, e);
                    }
                }
            }
        }
        l9(a) {
            if (!super.l9(a)) {
                return false;
            }
            let b = this.mh(a);
            if (!b.c) {
                return false;
            }
            return true;
        }
        ip() {
            super.ip();
            if (!this.aq.c && !this.ca()) {
                return;
            }
            if (this.ca()) {
                this.ok(this.l4, false);
            }
            else {
                this.ok(this.l2, false);
            }
        }
        oj(a, b, c, d) {
            let e = this.mh(a);
            if (!e.c) {
                return;
            }
            let f = e.d;
            f = a.lm(f, c, d);
            let g = this.k4;
            if (g == null) {
                g = this.k6;
            }
            if (g == null) {
                g = a.k4;
                if (g != null) {
                    g = this.m7.b8(g);
                }
            }
            let h = g;
            let i = g;
            if (this.pb != null) {
                h = this.pb;
            }
            if (this.pc != null) {
                i = this.pc;
            }
            b.ac.add(h);
            b.af.add(i);
            b.ad.add(f.y);
            b.ae.add(f.x);
            if (this.nb) {
                AxisAnnotationFrameManager.c(b, f, a, this.bs, this.getEffectiveViewport(), g, this.pd, this.pf, this.pe, this.pj, this.nk, this.pg, this.pi, this.ph, this.pk, this.np, this.pm == 0, this.pl == 0);
            }
        }
        ok(a, b) {
            let c = false;
            if (this.ne == null) {
                c = true;
                this.nf = new List$1(Axis.$, 0);
                this.ne = new Dictionary$2(Axis.$, Pool$1.$.specialize(AxisAnnotation.$), 0);
            }
            AxisAnnotationFrameManager.d(this, a, c, this.ne, this.nf, b, this.nq, this.nr, this.xAxisAnnotationFormatLabel, this.yAxisAnnotationFormatLabel);
        }
        oi(a, b, c, d, e) {
            let f = a.item(b);
            b++;
            if (e) {
                f._stroke = d.af._inner[c];
                f._fill = d.af._inner[c];
            }
            else {
                f._stroke = d.ac._inner[c];
                f._fill = d.ac._inner[c];
            }
            f.ac = this.ey;
            f.ai = this.lc;
            f.ad = this.ld;
            return new Tuple$2(Path.$, Number_$type, f, b);
        }
        mr(a, b) {
            super.mr(a, b);
            let c = this.m7.b2;
            let d = a;
            let e = d.ad.count;
            let f = 0;
            let g = b.br.left;
            let h = b.br.right;
            let i = b.br.top;
            let j = b.br.bottom;
            let k = this.pm == 0;
            let l = this.pl == 0;
            for (let m = 0; m < e; m++) {
                let n = Math.floor(d.ad._inner[m]);
                let o = Math.floor(d.ae._inner[m]);
                let p = null;
                if (k) {
                    if (isNaN_(n)) {
                        continue;
                    }
                    let q = this.oi(c, f, m, d, true);
                    p = q.c;
                    f = q.d;
                    let r = new PathGeometry();
                    let s = new PathFigure();
                    s._startPoint = { $type: Point_$type, x: o, y: i };
                    let t = new LineSegment(1);
                    t.c = { $type: Point_$type, x: o, y: j };
                    s._segments.add(t);
                    r.c.add(s);
                    p.ak = r;
                }
                if (l) {
                    if (isNaN_(n)) {
                        continue;
                    }
                    let u = this.oi(c, f, m, d, false);
                    p = u.c;
                    f = u.d;
                    let v = new PathGeometry();
                    let w = new PathFigure();
                    w._startPoint = { $type: Point_$type, x: g, y: n };
                    let x = new LineSegment(1);
                    x.c = { $type: Point_$type, x: h, y: n };
                    w._segments.add(x);
                    v.c.add(w);
                    p.ak = v;
                }
            }
            c.count = f;
            if (this.ca()) {
                this.ok(this.l4, true);
            }
            else {
                this.ok(this.l2, false);
            }
        }
        c8() {
            return true;
        }
        i0(a, b, c, d) {
            super.i0(a, b, c, d);
            switch (b) {
                case CrosshairLayer.$$p[1]:
                    this.je(true);
                    break;
                case CrosshairLayer.$$p[7]:
                    this.je(true);
                    break;
                case CrosshairLayer.$$p[4]:
                    this.je(true);
                    break;
                case CrosshairLayer.$$p[2]:
                case CrosshairLayer.$$p[8]:
                case CrosshairLayer.$$p[10]:
                case CrosshairLayer.$$p[12]:
                case CrosshairLayer.$$p[14]:
                case CrosshairLayer.$$p[13]:
                case CrosshairLayer.$$p[11]:
                case CrosshairLayer.$$p[15]:
                case CrosshairLayer.$$p[16]:
                case CrosshairLayer.$$p[17]:
                case CrosshairLayer.$$p[19]:
                case CrosshairLayer.$$p[21]:
                case CrosshairLayer.$$p[23]:
                case CrosshairLayer.$$p[22]:
                case CrosshairLayer.$$p[20]:
                case CrosshairLayer.$$p[24]:
                case CrosshairLayer.$$p[25]:
                case CrosshairLayer.$$p[0]:
                case CrosshairLayer.$$p[6]:
                case CrosshairLayer.$$p[5]:
                    this.je(true);
                    break;
            }
        }
    }
    CrosshairLayer.$t = /*@__PURE__*/ markType(CrosshairLayer, 'CrosshairLayer', AnnotationLayer.$);
    CrosshairLayer.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, CrosshairLayer, 'raisePropertyChanged', ['HorizontalLineStroke:pb:ol', [Brush.$, null], 'HorizontalLineVisibility:pl:om', [Visibility_$type, /*@__PURE__*/ enumGetBox(Visibility_$type, 0)], 'IsAxisAnnotationEnabled:nb:on', [0, false], 'SkipUnknownValues:nc:oo', [0, true], 'TargetSeries:m8:op', [Series.$, null], 'UseInterpolation:nd:oq', [0, true], 'VerticalLineStroke:pc:or', [Brush.$, null], 'VerticalLineVisibility:pm:os', [Visibility_$type, /*@__PURE__*/ enumGetBox(Visibility_$type, 0)], 'XAxisAnnotationBackground:pd:ot', [Brush.$, null], 'XAxisAnnotationInterpolatedValuePrecision:nq:ou', [1, -1], 'XAxisAnnotationOutline:pe:ov', [Brush.$, null], 'XAxisAnnotationPaddingBottom:ng:ow', [1, NaN], 'XAxisAnnotationPaddingLeft:nh:ox', [1, NaN], 'XAxisAnnotationPaddingRight:ni:oy', [1, NaN], 'XAxisAnnotationPaddingTop:nj:oz', [1, NaN], 'XAxisAnnotationStrokeThickness:nk:o0', [1, NaN], 'XAxisAnnotationTextColor:pf:o1', [Brush.$, null], 'YAxisAnnotationBackground:pg:o2', [Brush.$, null], 'YAxisAnnotationInterpolatedValuePrecision:nr:o3', [1, -1], 'YAxisAnnotationOutline:ph:o4', [Brush.$, null], 'YAxisAnnotationPaddingBottom:nl:o5', [1, NaN], 'YAxisAnnotationPaddingLeft:nm:o6', [1, NaN], 'YAxisAnnotationPaddingRight:nn:o7', [1, NaN], 'YAxisAnnotationPaddingTop:no:o8', [1, NaN], 'YAxisAnnotationStrokeThickness:np:o9', [1, NaN], 'YAxisAnnotationTextColor:pi:pa', [Brush.$, null]]);
    return CrosshairLayer;
})();
/**
 * @hidden
 */
export let CrosshairLayerView = /*@__PURE__*/ (() => {
    class CrosshairLayerView extends AnnotationLayerView {
        constructor(a) {
            super(a);
            this.b1 = null;
            this.b2 = null;
            this.b3 = null;
            this.b1 = a;
            this.b3 = new List$1(Path.$, 0);
        }
        ap() {
            super.ap();
            this.b2 = ((() => {
                let $ret = new Pool$1(Path.$);
                $ret.create = runOn(this, this.b9);
                $ret.activate = runOn(this, this.b4);
                $ret.disactivate = runOn(this, this.b6);
                $ret.destroy = runOn(this, this.b5);
                return $ret;
            })());
        }
        b9() {
            let a = new Path();
            a.j = new TranslateTransform();
            this.b3.add(a);
            return a;
        }
        b4(a) {
            a._visibility = 0;
        }
        b6(a) {
            a._visibility = 1;
        }
        b5(a) {
            this.b3.remove(a);
        }
        b7(a, b, c, d) {
            if (a.ak == null || a.ak.c.x != d || a.ak.d.x != c) {
                let e = ((() => {
                    let $ret = new LineGeometry();
                    $ret.d = { $type: Point_$type, x: c, y: b };
                    $ret.c = { $type: Point_$type, x: d, y: b };
                    return $ret;
                })());
                a.ak = e;
            }
        }
        b8(a) {
            if (a == null) {
                return a;
            }
            return BrushUtil.l(a, 0.1);
        }
        a3(a, b) {
            super.a3(a, b);
            if (a.d && !b) {
                for (let c = 0; c < this.b3.count; c++) {
                    let d = this.b3._inner[c];
                    if (d._visibility == 0) {
                        a.s(d);
                    }
                }
            }
        }
        ai(a) {
            super.ai(a);
            for (let b = 0; b < this.b3.count; b++) {
                this.e.a2.exportPathData(a, this.b3._inner[b], "crosshairLine", ["Main", "Crosshair"]);
            }
        }
    }
    CrosshairLayerView.$t = /*@__PURE__*/ markType(CrosshairLayerView, 'CrosshairLayerView', AnnotationLayerView.$);
    return CrosshairLayerView;
})();
//# sourceMappingURL=CrosshairLayer_combined.js.map
