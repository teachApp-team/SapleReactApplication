/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { FinancialSeries } from "./FinancialSeries";
import { ITrendLineSeries_$type } from "./ITrendLineSeries";
import { TrendLineType_$type } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { PenLineCap_$type } from "igniteui-react-core";
import { DoubleCollection } from "igniteui-react-core";
import { PriceDisplayType_$type } from "./PriceDisplayType";
import { enumGetBox, EnumUtil, typeCast, fromEnum, runOn, Point_$type, markType, markDep } from "igniteui-react-core";
import { CategoryFrame } from "./CategoryFrame";
import { ISortingAxis_$type } from "./ISortingAxis";
import { FinancialSeriesView } from "./FinancialSeriesView";
import { Series } from "./Series";
import { Rect } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { RectUtil } from "igniteui-react-core";
import { CategoryTrendLineManagerFactory } from "./CategoryTrendLineManagerFactory";
import { AxisRange } from "./AxisRange";
import { ScalerParams } from "./ScalerParams";
import { TrendResolutionParams } from "./TrendResolutionParams";
import { Pool$1 } from "igniteui-react-core";
import { Path } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { GeometryGroup } from "igniteui-react-core";
import { LineGeometry } from "igniteui-react-core";
import { RectangleGeometry } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { truncate, isNaN_ } from "igniteui-react-core";
import { boxArray$1 } from "igniteui-react-core";
import { FinancialPriceBucketCalculator } from "./FinancialPriceBucketCalculator";
import { Extensions } from "igniteui-react-core";
/**
 * @hidden
 */
export let FinancialPriceSeries = /*@__PURE__*/ (() => {
    class FinancialPriceSeries extends FinancialSeries {
        constructor() {
            super();
            this.ab = FinancialPriceSeries.$;
            this.mc = new CategoryFrame(5);
            this.me = new CategoryFrame(5);
            this.mb = new CategoryFrame(5);
        }
        bf() {
            return new FinancialPriceSeriesView(this);
        }
        iv(a) {
            super.iv(a);
            this.pk = a;
        }
        get p4() {
            return this.c(FinancialPriceSeries.pu);
        }
        set p4(a) {
            this.h(FinancialPriceSeries.pu, a);
        }
        hz(a, b, c, d) {
            super.hz(a, b, c, d);
            if (this.l9 != null && typeCast(ISortingAxis_$type, this.l9) !== null) {
                this.l9.i$i();
            }
            this.pk.bu.e(this.eu);
            if (this.pk.b4) {
                this.pk.b2.g$e(a, b, c, d);
            }
            if (this.mu != null) {
                this.mu.cn();
            }
            this.je(true);
        }
        bd() {
            if (this.be == 0) {
                return 1;
            }
            else {
                return super.bd();
            }
        }
        lv(a) {
            if (this.mb == null || this.mb.f.count == 0) {
                return Rect.empty;
            }
            let b = this.lh(a);
            let c = this.bi.bs;
            let d = this.bi.br;
            let e = this.getEffectiveViewport1(this.bi);
            let f = this.aj(this.l9, this.mb.f, this.n6(this.bi), this.n8(this.bi), a, true);
            let g = f[0];
            let h = f[1];
            let i = Math.abs(b.x - g[0]);
            let j = Math.abs(b.x - h[0]);
            let k = this.pm(this.mp, e);
            k = Math.max(k, 3);
            let l = (k - 1) / 2;
            if (i < j) {
                let m = g[0] - l;
                let n = g[0];
                let o = g[0] + l;
                let p = g[1];
                let q = g[2];
                let r = g[3];
                let s = g[4];
                let t = Math.min(Math.min(Math.min(p, q), r), s);
                let u = Math.max(Math.max(Math.max(p, q), r), s);
                return new Rect(0, m, t, Math.abs(o - m), u - t);
            }
            else {
                let v = h[0] - l;
                let w = h[0];
                let x = h[0] + l;
                let y = h[1];
                let z = h[2];
                let aa = h[3];
                let ab = h[4];
                let ac = Math.min(Math.min(Math.min(y, z), aa), ab);
                let ad = Math.max(Math.max(Math.max(y, z), aa), ab);
                return new Rect(0, v, ac, Math.abs(x - v), ad - ac);
            }
        }
        pj(a, b) {
            let c = a[0] - b;
            let d = a[0];
            let e = a[0] + b;
            let f = a[1];
            let g = a[2];
            let h = a[3];
            let i = a[4];
            let j = Math.min(Math.min(Math.min(f, g), h), i);
            let k = Math.max(Math.max(Math.max(f, g), h), i);
            let l = Math.min(g, h);
            let m = Math.max(g, h);
            let n = Math.min(f, i);
            let o = Math.max(f, i);
            if (this.pl == 1) {
                let p = new Array(3);
                let q = new Rect(0, c, f, b, 0);
                let r = new Rect(0, d, i, b, 0);
                let s = new Rect(0, d, l, 0, m - l);
                p[0] = q;
                p[1] = r;
                p[2] = s;
                return p;
            }
            else {
                let t = new Array(2);
                let u = new Rect(0, d, l, 0, m - l);
                let v = new Rect(0, c, n, b * 2, o - n);
                t[0] = u;
                t[1] = v;
                return t;
            }
        }
        ak(a) {
            let b = new List$1(Rect.$, 0);
            let c = this.lh(a);
            let d = this.bi.bs;
            let e = this.bi.br;
            let f = this.getEffectiveViewport1(this.bi);
            let g = this.aj(this.l9, this.mb.f, this.n6(this.bi), this.n8(this.bi), a, true);
            let h = g[0];
            let i = g[1];
            let j = Math.abs(c.x - h[0]);
            let k = Math.abs(c.x - i[0]);
            let l = this.pm(this.mp, f);
            l = Math.max(l, 3);
            let m = (l - 1) / 2;
            if (j < k) {
                return this.pj(h, m);
            }
            else {
                return this.pj(i, m);
            }
        }
        dh(a, b) {
            if (this.dk(a, b)) {
                return true;
            }
            return false;
        }
        dk(a, b) {
            let c = this.lw(a);
            if (c.isEmpty) {
                return false;
            }
            let d = RectUtil.r(c, (this.ey / 2) + this.ee(b));
            if (d.containsPoint(a)) {
                let e = this.al(a);
                if (e != null) {
                    for (let f = 0; f < e.length; f++) {
                        let g = e[f];
                        let h = RectUtil.r(g, (this.ey / 2) + this.ee(b));
                        if (h.containsPoint(a)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        i0(a, b, c, d) {
            switch (b) {
                case FinancialSeries.$$p[9]:
                    this.pk.ca();
                    break;
                case "TrendLineType":
                    let e = EnumUtil.getEnumValue(TrendLineType_$type, d);
                    if (e != 0) {
                        this.pk.b2 = CategoryTrendLineManagerFactory.a(this.pk.b2, this.l9, this.jy, this, this.b2);
                    }
                    break;
            }
            super.i0(a, b, c, d);
            if (this.pk.b4 && this.pk.b2 != null && this.pk.b2.g$b(a, b, c, d)) {
                this.je(false);
                this.il();
            }
            switch (b) {
                case FinancialPriceSeries.$$p[0]:
                    if (this.jy != null) {
                        this.pt();
                        this.mb.w();
                        this.o2(this.mb, this.pk);
                    }
                    this.il();
                    break;
                case "TrendLineBrush":
                    this.jp();
                    break;
                case "TrendLineType":
                    this.il();
                    break;
                case FinancialSeries.$$p[5]:
                case FinancialPriceSeries.$$p[1]:
                    this.ix();
                    break;
            }
        }
        pt() {
            this.pk.ce();
            if (this.bh != null) {
                this.bh.ce();
            }
        }
        an(a) {
            if (a != null && a == this.mu && this.m1 != null && !isNaN_(this.m1.minimum) && this.mz != null && !isNaN_(this.mz.maximum)) {
                return new AxisRange(this.m1.minimum, this.mz.maximum);
            }
            return null;
        }
        ao() {
            if (this.m1 == null || this.mz == null) {
                return null;
            }
            let a = new ScalerParams(0, this.bs.mr, this.bs.m5, this.l9.ca, this.getEffectiveViewport());
            let b = (this.l9.d1(this.bs.m5.left, a));
            let c = (this.l9.d1(this.bs.m5.right, a));
            let d = null;
            if (this.l9.cf) {
                d = this.l9;
                b = d.i$f(b);
                c = d.i$f(c);
            }
            else {
                b = Math.floor(b);
                c = Math.ceil(c);
            }
            b = Math.max(0, Math.min(this.m1.count - 1, b));
            c = Math.max(0, Math.min(this.m1.count - 1, c));
            let e = 1.7976931348623157E+308;
            let f = -1.7976931348623157E+308;
            for (let g = truncate(b); g <= truncate(c); g++) {
                let h = g;
                if (d != null) {
                    h = d.i$b._inner[g];
                }
                e = Math.min(e, this.m1.item(h));
                f = Math.max(f, this.mz.item(h));
            }
            return new AxisRange(e, f);
        }
        eh() {
            return Series.ei(this.m3, typeCast(ISortingAxis_$type, this.l9));
        }
        c9(a) {
            let b = this.bz != null ? this.bz.indexOf(a) : -1;
            let c = this.bi.bs;
            c = c.copy();
            let d = this.bi.br;
            let e = new Rect(0, 0, 0, 1, 1);
            let f = this.lt(this.bi);
            if (b >= 0 && Rect.l_op_Inequality(c, null) && Rect.l_op_Inequality(d, null)) {
                if (this.l9 != null) {
                    let g = new ScalerParams(0, e, e, this.l9.ca, f);
                    let h = this.l9.dy(b, g);
                    if (h < c.left + 0.1 * c.width) {
                        h = h + 0.4 * c.width;
                    }
                    if (h > c.right - 0.1 * c.width) {
                        h = h - 0.4 * c.width;
                    }
                    c.x = h - 0.5 * c.width;
                }
                if (this.mu != null && this.m1 != null && this.mz != null && b < this.m1.count && b < this.mz.count) {
                    let i = new ScalerParams(0, e, e, this.mu.ca, f);
                    i.b = this.eh();
                    let j = this.mu.dy(this.m1.item(b), i);
                    let k = this.mu.dy(this.mz.item(b), i);
                    if (!isNaN_(j) && !isNaN_(k)) {
                        let l = Math.abs(j - k);
                        if (c.height < l) {
                            c.height = l;
                            c.y = Math.min(j, k);
                        }
                        else {
                            if (j < c.top + 0.1 * c.height) {
                                j = j + 0.4 * c.height;
                            }
                            if (j > c.bottom - 0.1 * c.height) {
                                j = j - 0.4 * c.height;
                            }
                            c.y = j - 0.5 * c.height;
                        }
                    }
                }
                this.bn.ap(this.bs, c, true);
            }
            return b >= 0;
        }
        dw(a, b, c) {
            let d = super.dw(a, b, c);
            if (this.m3 == null || this.mx == null || this.mz == null || this.m1 == null) {
                d = false;
            }
            return d;
        }
        o0(a, b) {
            super.o0(a, b);
            let c = b.bs;
            let d = b.br;
            let e = this.getEffectiveViewport1(b);
            let f = this.l9;
            let g = this.mu;
            let h = new ScalerParams(0, c, d, f.ca, e);
            let i = ((() => {
                let $ret = new ScalerParams(0, c, d, g.ca, e);
                $ret.b = this.eh();
                return $ret;
            })());
            a.f.clear();
            a.m.clear();
            a.p.clear();
            let j = 0;
            let k = typeCast(ISortingAxis_$type, this.l9);
            if (k != null && (k.i$b == null || k.i$b.count != this.bz.count)) {
                return;
            }
            j = this.n0(c, d, e);
            let l = typeCast(FinancialPriceSeriesView.$, b);
            let m = this.eu;
            if (this.trendLineType != 0) {
                let n = new Array(this.bz.count);
                let o = 0;
                for (let p of fromEnum(this.nr)) {
                    n[o] = p;
                    o++;
                }
                if (this.pk.b4) {
                    this.pk.b2.prepareLineCore(a.p, this.trendLineType, boxArray$1(n), this.trendLinePeriod, (q) => this.l9.dy(q, h), (q) => this.mu.dy(q, i), ((() => {
                        let $ret = new TrendResolutionParams();
                        $ret.c = b.bu.b;
                        $ret.d = b.bu.c;
                        $ret.e = b.bu.d;
                        $ret.a = j;
                        $ret.b = m;
                        $ret.f = d;
                        return $ret;
                    })()));
                }
            }
            let q = this.l9.d1(2, h) - this.l9.d1(1, h);
            for (let r = b.bu.c; r <= b.bu.d; ++r) {
                let s;
                if (k == null) {
                    s = b.bu.getBucket(r);
                }
                else {
                    let t = k.i$b._inner[r];
                    let u = k.i$d(t);
                    let v = this.m3.item(t);
                    let w = this.mz.item(t);
                    let x = this.m1.item(t);
                    let y = this.mx.item(t);
                    let z = v;
                    let aa = w;
                    let ab = x;
                    let ac = y;
                    let ad = u;
                    while (r < b.bu.d) {
                        t = k.i$b._inner[r + 1];
                        ad = k.i$d(t);
                        if (ad - u > q * m) {
                            break;
                        }
                        r++;
                        aa = Math.max(aa, this.mz.item(t));
                        ab = Math.min(ab, this.m1.item(t));
                        ac = this.mx.item(t);
                    }
                    let ae = NaN;
                    if (!isNaN_(u)) {
                        ae = this.l9.dy(u, h);
                    }
                    s = [ae, z, aa, ab, ac];
                }
                if (!isNaN_(s[0])) {
                    if (k != null) {
                        s[0] = s[0] + j;
                    }
                    else {
                        s[0] = f.dy(s[0], h) + j;
                    }
                    s[1] = g.dy(s[1], i);
                    s[2] = g.dy(s[2], i);
                    s[3] = g.dy(s[3], i);
                    s[4] = g.dy(s[4], i);
                    a.f.add(s);
                }
            }
            return;
        }
        hw(a, b) {
            super.hw(a, b);
            let c = typeCast(FinancialPriceSeriesView.$, b);
            c.b8();
            if (a) {
                c.b3.count = 0;
            }
            if (c.b4 && c.b2 != null) {
                c.b2.g$d();
            }
        }
        get_nd() {
            return true;
        }
        o2(a, b) {
            super.o2(a, b);
            if (this.l9 == null || this.mu == null) {
                return;
            }
            let c = false;
            if (b.bx(a)) {
                c = true;
                b.bz(a);
            }
            this.mh.x(this, this.nh(), this.l9, runOn(this, this.l1), this.n6(b), this.n8(b));
            let d = false;
            let e = this.mh.c;
            if (e != null) {
                d = true;
            }
            let f = typeCast(FinancialPriceSeriesView.$, b);
            f.b7();
            f.b5 = false;
            if (f.b4) {
                f.b2.g$d();
            }
            if (this.trendLineType != 0) {
                f.b2.g$g(a.p);
            }
            if (d) {
                this.ps(a, b, c);
            }
            else {
                f.b3.count = 0;
                this.pr(a, b);
            }
        }
        eg() {
            let a = this.getEffectiveViewport1(this.bi);
            return this.pm(this.mp, a);
        }
        ps(a, b, c) {
            let d = this.pl;
            let e = this.getEffectiveViewport1(b);
            let f = this.pm(b, e);
            let g = (f - 1) / 2;
            let h = typeCast(FinancialPriceSeriesView.$, b);
            h.b5 = true;
            let i = a.f;
            let j = 0;
            let k = this.bz.count;
            let l = this.l9;
            let m = new ScalerParams(0, b.bs, b.br, l.ca, e);
            let n = this.k4;
            let o = this.pf;
            if (o == null) {
                o = n;
            }
            let p = this.k5;
            let q = this.p5;
            if (q == null) {
                q = p;
            }
            for (let r = 0; r < i.count; ++r) {
                let s = i._inner[r][0] - g;
                let t = i._inner[r][0];
                let u = i._inner[r][0] + g;
                let v = i._inner[r][1];
                let w = i._inner[r][2];
                let x = i._inner[r][3];
                let y = i._inner[r][4];
                if (isNaN_(v) || isNaN_(w) || isNaN_(x) || isNaN_(y)) {
                    continue;
                }
                let z = h.b3.item(j);
                j++;
                let aa = v < y;
                let ab = new PathGeometry();
                if (c) {
                    switch (d) {
                        case 0:
                            if (aa) {
                                let ac = v;
                                v = y;
                                y = ac;
                            }
                            let ad = new PathFigure();
                            ad._startPoint = { $type: Point_$type, x: t, y: x };
                            ad._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: t, y: v };
                                return $ret;
                            })()));
                            let ae = new PathFigure();
                            ae._startPoint = { $type: Point_$type, x: s, y: y };
                            ae._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: u, y: y };
                                return $ret;
                            })()));
                            ae._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: u, y: v };
                                return $ret;
                            })()));
                            ae._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: s, y: v };
                                return $ret;
                            })()));
                            ae._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: s, y: y };
                                return $ret;
                            })()));
                            let af = new PathFigure();
                            af._startPoint = { $type: Point_$type, x: t, y: y };
                            af._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: t, y: w };
                                return $ret;
                            })()));
                            ab.c.add(ad);
                            ab.c.add(ae);
                            ab.c.add(af);
                            break;
                        case 1:
                            let ag = new PathFigure();
                            ag._startPoint = { $type: Point_$type, x: s, y: v };
                            ag._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: t, y: v };
                                return $ret;
                            })()));
                            let ah = new PathFigure();
                            ah._startPoint = { $type: Point_$type, x: t, y: x };
                            ah._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: t, y: w };
                                return $ret;
                            })()));
                            let ai = new PathFigure();
                            ai._startPoint = { $type: Point_$type, x: t, y: y };
                            ai._segments.add(((() => {
                                let $ret = new LineSegment(1);
                                $ret.c = { $type: Point_$type, x: u, y: y };
                                return $ret;
                            })()));
                            ab.c.add(ag);
                            ab.c.add(ah);
                            ab.c.add(ai);
                            break;
                    }
                }
                if (aa) {
                    this.mh.al = o;
                    this.mh.ah = o;
                    this.mh.am = this.mh.ai = q;
                    this.mh.f = true;
                }
                else {
                    this.mh.al = n;
                    this.mh.ah = n;
                    this.mh.am = this.mh.ai = p;
                    this.mh.f = false;
                }
                this.oz(i, r, k, l, m, b.n);
                if (d == 1) {
                    this.mh.ae(z, true, false, false, false);
                }
                else {
                    this.mh.ae(z, false, false, false, false);
                }
                if (c) {
                    z.ak = ab;
                }
            }
            h.b3.count = j;
            h.b9();
        }
        pm(a, b) {
            let c = this.l9.jy(a.bs, a.br, b);
            c = Math.max(c, this.eu * 0.9);
            c = Math.max(c, 3);
            return c;
        }
        pr(a, b) {
            let c = this.pl;
            let d = this.getEffectiveViewport1(b);
            let e = this.pm(b, d);
            let f = (e - 1) / 2;
            let g = typeCast(FinancialPriceSeriesView.$, b);
            let h = g.ch();
            let i = g.cg();
            let j = a.f;
            for (let k = 0; k < j.count; ++k) {
                let l = j._inner[k][0] - f;
                let m = j._inner[k][0];
                let n = j._inner[k][0] + f;
                let o = j._inner[k][1];
                let p = j._inner[k][2];
                let q = j._inner[k][3];
                let r = j._inner[k][4];
                if (isNaN_(o) || isNaN_(p) || isNaN_(q) || isNaN_(r)) {
                    continue;
                }
                let s = o < r;
                let t = s ? i : h;
                switch (c) {
                    case 0:
                        if (s) {
                            let u = o;
                            o = r;
                            r = u;
                        }
                        t.d.add(((() => {
                            let $ret = new LineGeometry();
                            $ret.d = { $type: Point_$type, x: m, y: q };
                            $ret.c = { $type: Point_$type, x: m, y: o };
                            return $ret;
                        })()));
                        t.d.add(((() => {
                            let $ret = new RectangleGeometry();
                            $ret.e = new Rect(0, l, r, n - l, o - r);
                            return $ret;
                        })()));
                        t.d.add(((() => {
                            let $ret = new LineGeometry();
                            $ret.d = { $type: Point_$type, x: m, y: r };
                            $ret.c = { $type: Point_$type, x: m, y: p };
                            return $ret;
                        })()));
                        break;
                    case 1:
                        t.d.add(((() => {
                            let $ret = new LineGeometry();
                            $ret.d = { $type: Point_$type, x: l, y: o };
                            $ret.c = { $type: Point_$type, x: m, y: o };
                            return $ret;
                        })()));
                        t.d.add(((() => {
                            let $ret = new LineGeometry();
                            $ret.d = { $type: Point_$type, x: m, y: q };
                            $ret.c = { $type: Point_$type, x: m, y: p };
                            return $ret;
                        })()));
                        t.d.add(((() => {
                            let $ret = new LineGeometry();
                            $ret.d = { $type: Point_$type, x: m, y: r };
                            $ret.c = { $type: Point_$type, x: n, y: r };
                            return $ret;
                        })()));
                        break;
                }
            }
        }
        fv(a, b) {
            if (this.pk.b4 && a == this.pk.b2.g$j) {
                return null;
            }
            return super.fv(a, b);
        }
        jp() {
            super.jp();
            if (this.fh < 0) {
                return;
            }
            this.pk.cf();
        }
        h5(a) {
            super.h5(a);
            if (this.pk.b4) {
                this.a2.exportTrendlineData(this, a, this.pk.b2.g$j);
            }
        }
        jj(a, b) {
            super.jj(a, b);
            this.p5 = b;
        }
    }
    FinancialPriceSeries.$t = /*@__PURE__*/ markType(FinancialPriceSeries, 'FinancialPriceSeries', FinancialSeries.$, [ITrendLineSeries_$type]);
    FinancialPriceSeries.pu = /*@__PURE__*/ DependencyProperty.i("ActualTrendLineBrush", Brush.$, FinancialPriceSeries.$, /*@__PURE__*/ new PropertyMetadata(2, null, (a, b) => a.raisePropertyChanged("ActualTrendLineBrush", b.oldValue, b.newValue)));
    FinancialPriceSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, FinancialPriceSeries, 'raisePropertyChanged', ['DisplayType:pl:pv', [PriceDisplayType_$type, /*@__PURE__*/ enumGetBox(PriceDisplayType_$type, 0)], 'NegativeOutline:p5:pw', [Brush.$, null], 'TrendLineType::p2', [TrendLineType_$type, /*@__PURE__*/ enumGetBox(TrendLineType_$type, 0)], 'TrendLineThickness::p1', [1, 1.5], 'TrendLinePeriod::p0', [1, 7], 'TrendLineBrush::px', [Brush.$, null], 'TrendLineZIndex:po:p3', [1, 1001], 'TrendLineDashArray:p6:py', [DoubleCollection.$], 'TrendLineDashCap:p7:pz', [PenLineCap_$type, /*@__PURE__*/ enumGetBox(PenLineCap_$type, 0)]]);
    return FinancialPriceSeries;
})();
/**
 * @hidden
 */
export let FinancialPriceSeriesView = /*@__PURE__*/ (() => {
    class FinancialPriceSeriesView extends FinancialSeriesView {
        constructor(a) {
            super(a);
            this.b0 = null;
            this.b3 = null;
            this.b6 = null;
            this.ck = ((() => {
                let $ret = new Path();
                $ret.ak = new GeometryGroup();
                return $ret;
            })());
            this.cj = ((() => {
                let $ret = new Path();
                $ret.ak = new GeometryGroup();
                return $ret;
            })());
            this.b1 = null;
            this.ci = new Path();
            this.b5 = false;
            this.b0 = a;
            this.b6 = new List$1(Path.$, 0);
            this.b3 = ((() => {
                let $ret = new Pool$1(Path.$);
                $ret.create = runOn(this, this.cl);
                $ret.activate = runOn(this, this.cb);
                $ret.disactivate = runOn(this, this.cd);
                $ret.destroy = runOn(this, this.cc);
                return $ret;
            })());
        }
        cl() {
            let a = new Path();
            this.b6.add(a);
            a._visibility = 1;
            return a;
        }
        cb(a) {
            a._visibility = 0;
        }
        cd(a) {
            a._visibility = 1;
        }
        cc(a) {
            this.b6.remove(a);
        }
        bv() {
            return new FinancialPriceBucketCalculator(this);
        }
        ap() {
            super.ap();
            if (!this.n) {
                this.bw.pf = ((() => {
                    let $ret = new Brush();
                    $ret.fill = "#C62828";
                    return $ret;
                })());
                this.b0.p5 = this.bw.pf;
                this.bw.eu = 5;
                this.bw.ey = 1;
            }
        }
        get b2() {
            if (this.b1 == null) {
                this.b1 = CategoryTrendLineManagerFactory.a(this.b1, this.e.ap(), this.e.jy, this.e, this.e.b2);
            }
            return this.b1;
        }
        set b2(a) {
            this.b1 = a;
        }
        get b4() {
            return this.b1 != null;
        }
        ce() {
            if (this.b0.pl == 1) {
                this.ck._stroke = this.e.k4;
            }
            else {
                this.ck._stroke = this.e.k5;
            }
            if (this.b0.pl == 1) {
                this.cj._stroke = this.bw.pf;
            }
            else {
                this.cj._stroke = this.b0.p5;
            }
        }
        b8() {
            this.an();
            this.b3.count = 0;
            this.b7();
        }
        b7() {
            let a = typeCast(GeometryGroup.$, this.ck.ak);
            let b = typeCast(GeometryGroup.$, this.cj.ak);
            Extensions.d(a);
            Extensions.d(b);
        }
        ch() {
            this.an();
            return typeCast(GeometryGroup.$, this.ck.ak);
        }
        cg() {
            this.an();
            return typeCast(GeometryGroup.$, this.cj.ak);
        }
        cf() {
            this.b0.p4 = null;
            if (this.b0.trendLineBrush != null) {
                this.b0.p4 = this.b0.trendLineBrush;
            }
            else {
                this.b0.p4 = this.b0.k4;
            }
        }
        a8() {
            super.a8();
            this.ck.ac = this.e.ey;
            this.ck.ai = this.e.lc;
            this.ck.ad = this.e.ld;
            if (this.b0.pl == 1) {
                this.ck._stroke = this.e.k4;
            }
            else {
                this.ck._stroke = this.e.k5;
                this.ck._fill = this.e.k4;
            }
            this.cj.ac = this.e.ey;
            this.cj.ai = this.e.lc;
            this.cj.ad = this.e.ld;
            if (this.b0.pl == 1) {
                this.cj._stroke = this.bw.pf;
            }
            else {
                this.cj._stroke = this.b0.p5;
                this.cj._fill = this.bw.pf;
            }
        }
        a9() {
            super.a9();
            let a = this.bl();
            this.ck.ac = this.e.ey + 3;
            if (this.b0.pl == 1) {
                this.ck._stroke = a;
            }
            else {
                this.ck._stroke = a;
                this.ck._fill = a;
            }
            this.cj.ac = this.e.ey + 3;
            if (this.b0.pl == 1) {
                this.cj._stroke = a;
            }
            else {
                this.cj._stroke = a;
                this.cj._fill = a;
            }
        }
        z(a) {
            return this.b6._inner[a];
        }
        y(a) {
            let b = this.b6._inner[a];
            this.ci._visibility = b._visibility;
            this.ci.ak = b.ak;
            let c = this.bm(a);
            this.ci._fill = c;
            this.ci._stroke = c;
            this.ci.ac = this.e.ey + 3;
            return this.ci;
        }
        a3(a, b) {
            super.a3(a, b);
            if (a.d) {
                if (this.b5) {
                    for (let c = 0; c < this.b6.count; c++) {
                        let d = this.x(c, b);
                        if (d._visibility == 0) {
                            a.s(d);
                        }
                    }
                }
                else {
                    a.s(this.ck);
                    a.s(this.cj);
                }
            }
        }
        a2(a, b) {
            if (a.d) {
                if (this.b0.trendLineType != 0 && !b) {
                    let c = this.b2.g$j;
                    c.ac = this.b0.trendLineThickness;
                    c._stroke = this.b0.p4;
                    c.ai = this.b0.p6;
                    c.ad = this.b0.p7;
                    a.u(c);
                }
            }
            super.a2(a, b);
        }
        ai(a) {
            super.ai(a);
            this.e.a2.exportPathData(a, this.ck, "positivePathShape", ["Positive", "Main"]);
            this.e.a2.exportPathData(a, this.cj, "negativePathShape", ["Negative"]);
        }
        b9() {
            this.an();
        }
        ca() {
            if (this.b4) {
                this.b1 = CategoryTrendLineManagerFactory.a(this.b1, this.e.ap(), this.e.jy, this.e, this.e.b2);
            }
        }
    }
    FinancialPriceSeriesView.$t = /*@__PURE__*/ markType(FinancialPriceSeriesView, 'FinancialPriceSeriesView', FinancialSeriesView.$);
    return FinancialPriceSeriesView;
})();
//# sourceMappingURL=FinancialPriceSeries_combined.js.map
