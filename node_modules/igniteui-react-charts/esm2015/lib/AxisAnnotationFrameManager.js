/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, typeCast, Number_$type, markType } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { Color } from "igniteui-react-core";
import { LinearGradientBrush } from "igniteui-react-core";
import { ColorUtil } from "igniteui-react-core";
import { Thickness } from "igniteui-react-core";
import { Axis } from "./Axis";
import { ScalerParams } from "./ScalerParams";
import { List$1 } from "igniteui-react-core";
import { Dictionary$2 } from "igniteui-react-core";
import { Pool$1 } from "igniteui-react-core";
import { AxisAnnotation } from "./AxisAnnotation";
import { HashSet$1 } from "igniteui-react-core";
import { truncate, log10 } from "igniteui-react-core";
import { round10N } from "igniteui-react-core";
/**
 * @hidden
 */
export let AxisAnnotationFrameManager = /*@__PURE__*/ (() => {
    class AxisAnnotationFrameManager extends Base {
        static e(a, b, c) {
            let d = new Color();
            if (typeCast(LinearGradientBrush.$, a) !== null) {
                if (a.gradientStops == null || a.gradientStops.length < 1) {
                    let e = new Brush();
                    e.color = b;
                    return e;
                }
                d = a.gradientStops[0].color;
            }
            else {
                d = a.color;
            }
            let f = ColorUtil.a(d);
            let g = ColorUtil.a(c);
            let h = ColorUtil.a(b);
            let i = (f[3] + 0.05) / (h[3] + 0.05);
            let j = (g[3] + 0.05) / (f[3] + 0.05);
            if (i > j) {
                let k = new Brush();
                k.color = b;
            }
            let l = new Brush();
            l.color = c;
            return l;
        }
        static c(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {
            let s = c.ag();
            let t = null;
            let u = null;
            for (let v = 0; v < s.length; v++) {
                if (s[v].ch) {
                    u = s[v];
                }
                else {
                    t = s[v];
                }
            }
            let w = Color.u(255, 102, 102, 102);
            let x = Color.u(255, 255, 255, 255);
            if (t != null) {
                let y = new ScalerParams(1, d.mr, t.i8, t.ca);
                y.c = e;
                let z = t.d1(b.x, y);
                a.p.add(z);
                a.o.add(z);
                if (g != null) {
                    a.g.add(g);
                }
                else {
                    a.g.add(f);
                }
                if (h != null) {
                    a.n.add(h);
                }
                else {
                    a.n.add(AxisAnnotationFrameManager.e(a.g._inner[a.g.count - 1], w, x));
                }
                a.j.add(j.c);
                a.l.add(j.e);
                a.k.add(j.d);
                a.i.add(j.b);
                if (k != null) {
                    a.m.add(k);
                }
                else {
                    a.m.add(NaN);
                }
                if (i != null) {
                    a.h.add(i);
                }
                else {
                    a.h.add(null);
                }
                if (q) {
                    a.f.add(t);
                }
                else {
                    a.f.add(null);
                }
            }
            if (u != null) {
                let aa = new ScalerParams(1, d.mr, u.i8, u.ca);
                aa.c = e;
                let ab = u.d1(b.y, aa);
                a.aa.add(ab);
                a.z.add(ab);
                if (l != null) {
                    a.r.add(l);
                }
                else {
                    a.r.add(f);
                }
                if (m != null) {
                    a.y.add(m);
                }
                else {
                    a.y.add(AxisAnnotationFrameManager.e(a.r._inner[a.r.count - 1], w, x));
                }
                a.u.add(o.c);
                a.w.add(o.e);
                a.v.add(o.d);
                a.t.add(o.b);
                if (p != null) {
                    a.x.add(p);
                }
                else {
                    a.x.add(NaN);
                }
                if (n != null) {
                    a.s.add(n);
                }
                else {
                    a.s.add(null);
                }
                if (r) {
                    a.q.add(u);
                }
                else {
                    a.q.add(null);
                }
            }
        }
        static b(a) {
            a.f.clear();
            a.q.clear();
            a.p.clear();
            a.aa.clear();
            a.o.clear();
            a.z.clear();
            a.g.clear();
            a.h.clear();
            a.j.clear();
            a.l.clear();
            a.k.clear();
            a.i.clear();
            a.m.clear();
            a.n.clear();
            a.r.clear();
            a.s.clear();
            a.u.clear();
            a.w.clear();
            a.v.clear();
            a.t.clear();
            a.x.clear();
            a.y.clear();
        }
        static a(a, b, c) {
            if (!b.cc) {
                return a;
            }
            let d = 0;
            if (c >= 0) {
                d = c;
            }
            else {
                let e = b.d9();
                d = e == 0 ? 0 : truncate(Math.max(-Math.floor(log10(e)), 0));
                d += 1;
            }
            return round10N(a, d);
        }
        static d(a, b, c, d, e, f, g, h, i, j) {
            let k = new List$1(Axis.$, 0);
            let l = new HashSet$1(Axis.$, 0);
            let m = new Dictionary$2(Axis.$, Number_$type, 0);
            for (let n = 0; n < b.p.count; n++) {
                let o = b.f._inner[n];
                if (o != null) {
                    if (!l.contains(o)) {
                        k.add(o);
                        m.item(o, 0);
                        l.add_1(o);
                    }
                    let p;
                    if (!d.containsKey(o)) {
                        p = new Pool$1(AxisAnnotation.$);
                        p.create = () => new AxisAnnotation();
                        p.destroy = (q) => {
                        };
                        p.activate = (q) => o.am.add(q);
                        p.disactivate = (q) => o.am.remove(q);
                        d.item(o, p);
                        e.add(o);
                    }
                    else {
                        p = d.item(o);
                    }
                    let q = p.item(m.item(o));
                    m.item(o, m.item(o) + 1);
                    q.k = false;
                    q.value = b.o._inner[n];
                    let r = b.p._inner[n];
                    if (i != null) {
                        let s = i(r);
                        q.text = s;
                    }
                    else {
                        r = AxisAnnotationFrameManager.a(r, o, g);
                        q.text = o.fl(r);
                    }
                    q.textColor = b.n._inner[n];
                    q.background = b.g._inner[n];
                    q.backgroundPadding = new Thickness(1, b.j._inner[n], b.l._inner[n], b.k._inner[n], b.i._inner[n]);
                    q.outline = b.h._inner[n];
                    q.strokeThickness = b.m._inner[n];
                    if (q.k) {
                        q.k = false;
                        c = true;
                    }
                }
            }
            for (let t = 0; t < b.aa.count; t++) {
                let u = b.q._inner[t];
                if (u != null) {
                    if (!l.contains(u)) {
                        k.add(u);
                        m.item(u, 0);
                        l.add_1(u);
                    }
                    let v;
                    if (!d.containsKey(u)) {
                        v = new Pool$1(AxisAnnotation.$);
                        v.create = () => new AxisAnnotation();
                        v.destroy = (w) => {
                        };
                        v.activate = (w) => u.am.add(w);
                        v.disactivate = (w) => u.am.remove(w);
                        d.item(u, v);
                        e.add(u);
                    }
                    else {
                        v = d.item(u);
                    }
                    let w = v.item(m.item(u));
                    m.item(u, m.item(u) + 1);
                    w.k = false;
                    let x = b.aa._inner[t];
                    w.value = b.z._inner[t];
                    if (j != null) {
                        let y = j(x);
                        w.text = y;
                    }
                    else {
                        x = AxisAnnotationFrameManager.a(x, u, h);
                        w.text = u.fl(x);
                    }
                    w.textColor = b.y._inner[t];
                    w.background = b.r._inner[t];
                    w.backgroundPadding = new Thickness(1, b.u._inner[t], b.w._inner[t], b.v._inner[t], b.t._inner[t]);
                    w.outline = b.s._inner[t];
                    w.strokeThickness = b.x._inner[t];
                    if (w.k) {
                        w.k = false;
                        c = true;
                    }
                }
            }
            for (let z = 0; z < k.count; z++) {
                if (d.containsKey(k._inner[z])) {
                    let aa = d.item(k._inner[z]);
                    aa.count = m.item(k._inner[z]);
                }
            }
            for (let ab = e.count - 1; ab >= 0; ab--) {
                if (!l.contains(e._inner[ab])) {
                    c = true;
                    let ac = d.item(e._inner[ab]);
                    ac.count = 0;
                    ac.activate = null;
                    ac.create = null;
                    ac.destroy = null;
                    ac.disactivate = null;
                    d.removeItem(e._inner[ab]);
                    e.removeAt(ab);
                }
            }
            if (c && f) {
                for (let ad = 0; ad < k.count; ad++) {
                    let ae = k._inner[ad];
                    if (ae.a4.c) {
                        ae.gp(true);
                        ae.a4.c = false;
                    }
                }
            }
        }
    }
    AxisAnnotationFrameManager.$t = /*@__PURE__*/ markType(AxisAnnotationFrameManager, 'AxisAnnotationFrameManager');
    return AxisAnnotationFrameManager;
})();
//# sourceMappingURL=AxisAnnotationFrameManager.js.map
